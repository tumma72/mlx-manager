---
phase: 05-chat-multimodal-support
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - frontend/src/routes/(protected)/chat/+page.svelte
  - frontend/src/lib/components/ui/thinking-bubble.svelte
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User sees assistant response stream in real-time"
    - "User sees thinking content stream live before response"
    - "Thinking section shows 'Thought for Xs' after completion"
    - "Attached images are encoded and sent to model"
    - "Non-multimodal models receive text-only messages"
  artifacts:
    - path: "frontend/src/routes/(protected)/chat/+page.svelte"
      provides: "Streaming chat UI with multimodal support"
      contains: "EventSource"
    - path: "frontend/src/lib/components/ui/thinking-bubble.svelte"
      provides: "Thinking display with timing"
      contains: "Thought for"
  key_links:
    - from: "chat/+page.svelte"
      to: "/api/chat/completions"
      via: "fetch with ReadableStream for SSE"
      pattern: "fetch.*api/chat"
    - from: "chat/+page.svelte"
      to: "authStore.token"
      via: "Authorization header"
      pattern: "authStore\\.token"
---

<objective>
Update chat page to consume SSE streaming and encode multimodal messages.

Purpose: Transform the chat from request-response to real-time streaming with live thinking display and proper image encoding for multimodal models.

Output: Streaming chat UI with "Thought for Xs" display and base64 image encoding.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-chat-multimodal-support/05-CONTEXT.md
@.planning/phases/05-chat-multimodal-support/05-RESEARCH.md
@.planning/phases/05-chat-multimodal-support/05-01-SUMMARY.md
@.planning/phases/05-chat-multimodal-support/05-02-SUMMARY.md
@frontend/src/routes/(protected)/chat/+page.svelte
@frontend/src/lib/components/ui/thinking-bubble.svelte
@frontend/src/lib/stores/auth.svelte.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ThinkingBubble for streaming with timing</name>
  <files>frontend/src/lib/components/ui/thinking-bubble.svelte</files>
  <action>
Update the ThinkingBubble component to support streaming thinking content and display "Thought for Xs" summary.

**Replace the existing component with:**

```svelte
<script lang="ts">
  import { Collapsible } from 'bits-ui';
  import { ChevronDown, ChevronRight, Brain, Loader2 } from 'lucide-svelte';

  interface Props {
    content: string;
    duration?: number; // seconds
    streaming?: boolean;
    defaultExpanded?: boolean;
  }

  let { content, duration, streaming = false, defaultExpanded = false }: Props = $props();

  let expanded = $state(getInitialExpanded());
  function getInitialExpanded() {
    return defaultExpanded || streaming; // Auto-expand while streaming
  }

  // Auto-collapse when streaming finishes
  $effect(() => {
    if (!streaming && duration !== undefined) {
      expanded = false;
    }
  });

  const label = $derived.by(() => {
    if (streaming) return 'Thinking...';
    if (duration !== undefined) return `Thought for ${duration.toFixed(1)}s`;
    return 'Thinking';
  });
</script>

<div class="my-2">
  <Collapsible.Root bind:open={expanded}>
    <Collapsible.Trigger
      class="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors"
    >
      {#if expanded}
        <ChevronDown class="w-4 h-4" />
      {:else}
        <ChevronRight class="w-4 h-4" />
      {/if}
      {#if streaming}
        <Loader2 class="w-4 h-4 animate-spin" />
      {:else}
        <Brain class="w-4 h-4" />
      {/if}
      <span>{label}</span>
    </Collapsible.Trigger>
    <Collapsible.Content>
      <div class="mt-2 pl-6 border-l-2 border-muted text-sm text-muted-foreground italic whitespace-pre-wrap">
        {content}
      </div>
    </Collapsible.Content>
  </Collapsible.Root>
</div>
```

Key changes:
- Added `duration` prop for "Thought for Xs" display
- Added `streaming` prop to show spinner while thinking
- Auto-expands during streaming, auto-collapses when done
- Uses bits-ui Collapsible for accessibility
  </action>
  <verify>Run `npm run check` in frontend/ - should pass</verify>
  <done>
- ThinkingBubble shows "Thinking..." while streaming
- ThinkingBubble shows "Thought for Xs" after completion
- Auto-expands during streaming, auto-collapses when done
- Uses bits-ui Collapsible for accessibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Update chat page for streaming and multimodal</name>
  <files>frontend/src/routes/(protected)/chat/+page.svelte</files>
  <action>
Replace the non-streaming fetch with SSE streaming via fetch + ReadableStream. Add image encoding for multimodal messages.

**EXISTING STATE (from Plan 05-01):**
- `attachments` state for file attachments
- `isMultimodal` derived from selectedProfile.model_type
- `error` state for error messages
- `Attachment` and `ContentPart` types imported

**NEW IMPORTS (add to existing imports):**
```typescript
import { authStore } from '$stores';  // Path: frontend/src/lib/stores/index.ts exports authStore
```

**NEW STATE (add to existing state):**
```typescript
let streamingThinking = $state('');
let streamingResponse = $state('');
let thinkingDuration = $state<number | undefined>(undefined);
let isStreaming = $state(false);
```

**ADD base64 encoding utility:**
```typescript
async function encodeFileAsBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}
```

**ADD multimodal message builder:**
```typescript
async function buildMessageContent(text: string, attachments: Attachment[]): Promise<string | ContentPart[]> {
  if (attachments.length === 0) {
    return text;
  }

  const parts: ContentPart[] = [{ type: 'text', text }];

  for (const attachment of attachments) {
    const base64 = await encodeFileAsBase64(attachment.file);
    parts.push({
      type: 'image_url',
      image_url: { url: base64 }
    });
  }

  return parts;
}
```

**REPLACE handleSubmit with streaming version:**
```typescript
async function handleSubmit(e: Event) {
  e.preventDefault();
  if (!input.trim() || !selectedProfile || loading) return;

  const userMessage = input.trim();
  input = '';
  error = null;

  // Build message content (with attachments if any)
  const content = await buildMessageContent(userMessage, attachments);

  // Clear attachments
  for (const attachment of attachments) {
    URL.revokeObjectURL(attachment.preview);
  }
  attachments = [];

  // Add user message to UI (display text only for user messages)
  messages.push({ role: 'user', content: userMessage });

  // Reset streaming state
  streamingThinking = '';
  streamingResponse = '';
  thinkingDuration = undefined;
  isStreaming = true;
  loading = true;

  // Build messages array for API (use full content with images)
  const apiMessages = messages.slice(0, -1).map(m => ({
    role: m.role,
    content: m.content
  }));
  apiMessages.push({ role: 'user', content });

  try {
    const response = await fetch('/api/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authStore.token}`,  // authStore.token is string | null
      },
      body: JSON.stringify({
        profile_id: selectedProfile.id,
        messages: apiMessages,
      }),
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const reader = response.body?.getReader();
    if (!reader) throw new Error('No response body');

    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || ''; // Keep incomplete line in buffer

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;

        try {
          const data = JSON.parse(line.slice(6));

          switch (data.type) {
            case 'thinking':
              streamingThinking += data.content;
              break;
            case 'thinking_done':
              thinkingDuration = data.duration;
              break;
            case 'response':
              streamingResponse += data.content;
              break;
            case 'error':
              error = data.content;
              break;
            case 'done':
              // Finalize message
              const finalContent = streamingThinking
                ? `<think>${streamingThinking}</think>${streamingResponse}`
                : streamingResponse;
              messages.push({ role: 'assistant', content: finalContent });
              break;
          }
        } catch {
          // Ignore parse errors
        }
      }
    }
  } catch (e) {
    error = e instanceof Error ? e.message : 'Failed to send message';
    // Remove the user message on error
    messages.pop();
  } finally {
    loading = false;
    isStreaming = false;
  }
}
```

**UPDATE the loading indicator to show streaming content:**
Replace the simple loader div (the one with Loader2 inside) with:

```svelte
{#if loading}
  <div class="flex gap-3">
    <div class="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center flex-shrink-0">
      <Bot class="w-5 h-5 text-primary" />
    </div>
    <div class="max-w-[80%] rounded-lg px-4 py-2 bg-muted">
      {#if streamingThinking}
        <ThinkingBubble
          content={streamingThinking}
          duration={thinkingDuration}
          streaming={thinkingDuration === undefined}
          defaultExpanded={true}
        />
      {/if}
      {#if streamingResponse}
        <Markdown content={streamingResponse} />
      {:else if !streamingThinking}
        <Loader2 class="w-5 h-5 animate-spin" />
      {/if}
    </div>
  </div>
{/if}
```

Note: The existing ThinkingBubble in completed messages doesn't need duration (it was rendered without streaming).
  </action>
  <verify>
1. `cd frontend && npm run check` - should pass
2. `cd frontend && npm run lint` - should pass
3. Start dev servers and test:
   - Send a message, verify response streams in real-time
   - Test with a thinking model, verify thinking streams and shows duration
   - Test with attachments on multimodal model
  </verify>
  <done>
- Chat responses stream in real-time via fetch + ReadableStream
- Thinking content streams live with "Thinking..." label
- "Thought for Xs" shows after thinking completes
- Attachments encoded as base64 and sent to model
- Proper error handling for connection issues
  </done>
</task>

</tasks>

<verification>
1. Frontend quality: `cd frontend && npm run check && npm run lint`
2. Integration test:
   - Start a text model server, send message, verify streaming response
   - Start a thinking model server (with reasoning_parser), verify thinking + response stream
   - Start a multimodal model server, attach image, verify it's sent
</verification>

<success_criteria>
- Chat responses stream in real-time
- Thinking content displays with timing
- Images encoded and sent with messages
- No quality gate failures
</success_criteria>

<output>
After completion, create `.planning/phases/05-chat-multimodal-support/05-03-SUMMARY.md`
</output>
