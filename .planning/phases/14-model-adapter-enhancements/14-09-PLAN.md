---
phase: 14-model-adapter-enhancements
plan: 09
type: execute
wave: 4
depends_on: ["14-08"]
files_modified:
  - backend/mlx_manager/models.py
  - backend/mlx_manager/mlx_server/services/cloud/router.py
  - backend/mlx_manager/routers/settings.py
  - frontend/src/lib/components/settings/ProviderForm.svelte
  - frontend/src/lib/api/types.ts
  - backend/tests/mlx_server/services/cloud/test_router.py
autonomous: true

must_haves:
  truths:
    - "BackendType supports generic OpenAI-compatible providers"
    - "BackendType supports generic Anthropic-compatible providers"
    - "Multiple providers of same API type can be configured"
    - "Custom base_url works for all provider types"
  artifacts:
    - path: "backend/mlx_manager/models.py"
      provides: "Extended BackendType enum and ApiType field"
      contains: "ApiType"
---

<objective>
Enable generic OpenAI-compatible and Anthropic-compatible provider support.

Purpose: Many providers (Together, Groq, Fireworks, Mistral, etc.) use OpenAI-compatible APIs. Others may use Anthropic-compatible APIs. Users need to configure custom providers with their base_url and specify which API type to use.

Output: Extended routing system that supports any provider with OpenAI or Anthropic compatible APIs.
</objective>

<context>
Current limitation:
- BackendType only has LOCAL, OPENAI, ANTHROPIC
- Can only configure one credential per backend type
- Custom base_url exists but tied to specific provider

Needed:
- Configure multiple providers (e.g., Together AND Groq)
- Each provider specifies API type (openai_compatible or anthropic_compatible)
- Router uses correct client based on API type
- Provider name used for routing rules, API type for request format
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Data Models</name>
  <files>backend/mlx_manager/models.py</files>
  <action>
Add ApiType enum and update CloudCredential:

1. Add ApiType enum:
```python
class ApiType(str, Enum):
    """API protocol type for cloud providers."""
    OPENAI = "openai"      # OpenAI-compatible API
    ANTHROPIC = "anthropic"  # Anthropic-compatible API
```

2. Add more BackendType values for common providers:
```python
class BackendType(str, Enum):
    """Backend types for routing."""
    LOCAL = "local"
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
    # Generic providers
    OPENAI_COMPATIBLE = "openai_compatible"
    ANTHROPIC_COMPATIBLE = "anthropic_compatible"
    # Common providers (convenience)
    TOGETHER = "together"
    GROQ = "groq"
    FIREWORKS = "fireworks"
    MISTRAL = "mistral"
    DEEPSEEK = "deepseek"
```

3. Add api_type to CloudCredential:
```python
class CloudCredential(SQLModel, table=True):
    """Encrypted cloud API credentials."""
    __tablename__ = "cloud_credentials"

    id: int | None = Field(default=None, primary_key=True)
    backend_type: BackendType  # Remove unique constraint
    api_type: ApiType = Field(default=ApiType.OPENAI)  # Which API protocol
    name: str = Field(default="")  # Display name (e.g., "Groq", "Together")
    encrypted_api_key: str
    base_url: str | None = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))
```

4. Update CloudCredentialCreate:
```python
class CloudCredentialCreate(SQLModel):
    backend_type: BackendType
    api_type: ApiType = ApiType.OPENAI
    name: str = ""
    api_key: str
    base_url: str | None = None
```

5. Update CloudCredentialResponse:
```python
class CloudCredentialResponse(SQLModel):
    id: int
    backend_type: BackendType
    api_type: ApiType
    name: str
    base_url: str | None
    created_at: datetime
```

6. Add default base URLs mapping:
```python
DEFAULT_BASE_URLS: dict[BackendType, str] = {
    BackendType.OPENAI: "https://api.openai.com",
    BackendType.ANTHROPIC: "https://api.anthropic.com",
    BackendType.TOGETHER: "https://api.together.xyz",
    BackendType.GROQ: "https://api.groq.com/openai",
    BackendType.FIREWORKS: "https://api.fireworks.ai/inference",
    BackendType.MISTRAL: "https://api.mistral.ai",
    BackendType.DEEPSEEK: "https://api.deepseek.com",
}

API_TYPE_FOR_BACKEND: dict[BackendType, ApiType] = {
    BackendType.OPENAI: ApiType.OPENAI,
    BackendType.ANTHROPIC: ApiType.ANTHROPIC,
    BackendType.TOGETHER: ApiType.OPENAI,
    BackendType.GROQ: ApiType.OPENAI,
    BackendType.FIREWORKS: ApiType.OPENAI,
    BackendType.MISTRAL: ApiType.OPENAI,
    BackendType.DEEPSEEK: ApiType.OPENAI,
    BackendType.OPENAI_COMPATIBLE: ApiType.OPENAI,
    BackendType.ANTHROPIC_COMPATIBLE: ApiType.ANTHROPIC,
}
```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
python -c "
from mlx_manager.models import (
    BackendType, ApiType, CloudCredential, CloudCredentialCreate,
    DEFAULT_BASE_URLS, API_TYPE_FOR_BACKEND
)

# Check new types exist
assert BackendType.TOGETHER.value == 'together'
assert BackendType.GROQ.value == 'groq'
assert ApiType.OPENAI.value == 'openai'
print('New BackendType values: OK')

# Check default URLs
assert 'together' in DEFAULT_BASE_URLS[BackendType.TOGETHER]
print('Default base URLs: OK')

# Check API type mapping
assert API_TYPE_FOR_BACKEND[BackendType.GROQ] == ApiType.OPENAI
print('API type mapping: OK')
"
```
  </verify>
  <done>
Data models extended with ApiType, new BackendType values, and default base URL mappings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Backend Router</name>
  <files>backend/mlx_manager/mlx_server/services/cloud/router.py</files>
  <action>
Update BackendRouter to use api_type for client selection:

1. Update _get_or_create_backend():
```python
async def _get_or_create_backend(
    self,
    backend_type: BackendType,
    credential: CloudCredential,
) -> OpenAICloudBackend | AnthropicCloudBackend:
    """Get or create cloud backend client based on API type."""

    # Determine API type
    api_type = credential.api_type
    if api_type is None:
        # Fallback to mapping for backwards compatibility
        api_type = API_TYPE_FOR_BACKEND.get(backend_type, ApiType.OPENAI)

    # Determine base URL
    base_url = credential.base_url
    if not base_url:
        base_url = DEFAULT_BASE_URLS.get(backend_type, "https://api.openai.com")

    # Get decrypted API key
    api_key = self._encryption.decrypt(credential.encrypted_api_key)

    # Create appropriate client based on API type
    if api_type == ApiType.ANTHROPIC:
        return AnthropicCloudBackend(
            api_key=api_key,
            base_url=base_url,
        )
    else:  # OPENAI or default
        return OpenAICloudBackend(
            api_key=api_key,
            base_url=base_url,
        )
```

2. Update credential lookup to support multiple credentials per backend_type:
   - Change from unique constraint to allowing multiple
   - Use (backend_type, name) or just id for lookup

3. Cache key should include more specificity:
```python
# OLD: self._cloud_backends: dict[BackendType, ...]
# NEW: self._cloud_backends: dict[int, ...]  # credential_id -> client
```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
python -c "
from mlx_manager.mlx_server.services.cloud.router import BackendRouter
from mlx_manager.models import ApiType, BackendType, API_TYPE_FOR_BACKEND

# Check API type mapping is used
assert API_TYPE_FOR_BACKEND[BackendType.GROQ] == ApiType.OPENAI
print('Router can determine API type from backend type: OK')
"
```
  </verify>
  <done>
Backend router updated to select client based on api_type, support multiple credentials, and use default base URLs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Settings API</name>
  <files>backend/mlx_manager/routers/settings.py</files>
  <action>
Update settings router for new credential fields:

1. Update create_credential endpoint:
   - Accept api_type in request
   - Accept name in request
   - Remove unique constraint validation (allow multiple per backend_type)

2. Update list_credentials endpoint:
   - Return api_type and name in response

3. Add endpoint for default base URLs:
```python
@router.get("/providers/defaults")
async def get_provider_defaults() -> dict[str, Any]:
    """Get default base URLs and API types for known providers."""
    return {
        "providers": [
            {"backend_type": bt.value, "base_url": url, "api_type": API_TYPE_FOR_BACKEND[bt].value}
            for bt, url in DEFAULT_BASE_URLS.items()
        ]
    }
```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
python -c "
from mlx_manager.routers.settings import router
routes = [r.path for r in router.routes]
print(f'Settings routes: {routes}')
"
```
  </verify>
  <done>
Settings API updated to handle new credential fields and provide provider defaults.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Frontend Provider Form</name>
  <files>
frontend/src/lib/components/settings/ProviderForm.svelte
frontend/src/lib/api/types.ts
  </files>
  <action>
Update frontend to support new provider configuration:

1. Update types.ts:
```typescript
export type ApiType = 'openai' | 'anthropic';

export type BackendType =
  | 'local'
  | 'openai'
  | 'anthropic'
  | 'openai_compatible'
  | 'anthropic_compatible'
  | 'together'
  | 'groq'
  | 'fireworks'
  | 'mistral'
  | 'deepseek';

export interface CloudCredential {
  id: number;
  backend_type: BackendType;
  api_type: ApiType;
  name: string;
  base_url: string | null;
  created_at: string;
}

export interface CloudCredentialCreate {
  backend_type: BackendType;
  api_type: ApiType;
  name: string;
  api_key: string;
  base_url: string | null;
}
```

2. Update ProviderForm.svelte:
   - Add provider type dropdown (OpenAI, Anthropic, Together, Groq, etc.)
   - When known provider selected, auto-fill base_url and api_type
   - When "Custom OpenAI-compatible" selected, show base_url input
   - Add name field for display purposes
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/frontend
npm run check 2>&1 | head -20
```
  </verify>
  <done>
Frontend updated with new provider types, API type selection, and auto-fill for known providers.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add Tests</name>
  <files>backend/tests/mlx_server/services/cloud/test_router.py</files>
  <action>
Add tests for new provider functionality:

1. Test API type selection:
   - GROQ uses OpenAI client
   - ANTHROPIC_COMPATIBLE uses Anthropic client

2. Test default base URLs:
   - Together gets correct URL
   - Custom base_url overrides default

3. Test multiple credentials:
   - Can have both Groq and Together configured
   - Router selects correct one based on mapping

4. Test backwards compatibility:
   - Old credentials without api_type still work
   - Falls back to API_TYPE_FOR_BACKEND mapping
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
pytest tests/mlx_server/services/cloud/test_router.py -v --tb=short
```
  </verify>
  <done>
Tests added for new provider functionality including API type selection and multiple credentials.
  </done>
</task>

<task type="human">
  <name>Task 6: Verification Checkpoint</name>
  <action>
Verify provider configuration works:

1. Run database migration if needed (new fields)

2. Run tests:
```bash
cd /Users/atomasini/Development/mlx-manager/backend
pytest -v --tb=short
```

3. Quality checks:
```bash
ruff check . && ruff format --check . && mypy mlx_manager
cd ../frontend && npm run check && npm run lint
```

4. Manual test:
   - Configure a Together or Groq provider
   - Create routing rule to route to it
   - Test that requests use correct API format
  </action>
</task>

</tasks>

<verification>
- [ ] ApiType enum added
- [ ] BackendType extended with common providers
- [ ] CloudCredential has api_type and name fields
- [ ] DEFAULT_BASE_URLS mapping works
- [ ] Router selects client based on api_type
- [ ] Multiple credentials per backend_type allowed
- [ ] Frontend updated with provider selection
- [ ] Tests pass
- [ ] Quality gates pass
</verification>

<success_criteria>
1. Can configure Together, Groq, Fireworks, etc. as providers
2. Custom OpenAI-compatible endpoints work
3. Custom Anthropic-compatible endpoints work
4. Routing rules can target any configured provider
5. API type determines request/response format
</success_criteria>

<output>
After completion, create `.planning/phases/14-model-adapter-enhancements/14-09-SUMMARY.md`
</output>
