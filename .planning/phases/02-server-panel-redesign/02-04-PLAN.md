---
phase: 02-server-panel-redesign
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - frontend/src/routes/servers/+page.svelte
autonomous: true

must_haves:
  truths:
    - "Scroll position is preserved across 5-second polling updates"
    - "User can scroll through server list without position jumping"
    - "Metrics update without causing layout shifts"
  artifacts:
    - path: "frontend/src/routes/servers/+page.svelte"
      provides: "Server page with robust scroll preservation"
      contains: "$effect.pre"
  key_links:
    - from: "+page.svelte"
      to: "serverStore.servers"
      via: "scroll restoration effect"
      pattern: "scrollTop"
---

<objective>
Implement robust scroll preservation for the server list during polling updates.

Purpose: The current double-RAF scroll restoration is fragile. When the server list updates every 5 seconds, scroll position can jump, disrupting user experience when monitoring multiple servers.

Output: Improved scroll preservation using container-scoped tracking and `$effect.pre` for timing.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-panel-redesign/02-RESEARCH.md
@.planning/phases/02-server-panel-redesign/02-03-SUMMARY.md

@frontend/src/routes/servers/+page.svelte
@frontend/src/lib/stores/servers.svelte.ts
@frontend/src/lib/utils/reconcile.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor scroll preservation to container-scoped approach</name>
  <files>frontend/src/routes/servers/+page.svelte</files>
  <action>
    Replace the current window-based scroll tracking with container-scoped approach:

    1. Add a scrollable container ref for the server list:
       ```typescript
       let serverListContainer: HTMLElement;
       let savedScrollTop = 0;
       ```

    2. Use `$effect.pre` to capture scroll position BEFORE updates:
       ```typescript
       // Capture scroll position before any DOM updates
       $effect.pre(() => {
         // Track dependency on server list
         void serverStore.servers.length;
         if (serverListContainer) {
           savedScrollTop = serverListContainer.scrollTop;
         }
       });
       ```

    3. Use `$effect` to restore scroll position AFTER updates:
       ```typescript
       // Restore scroll position after DOM updates
       $effect(() => {
         // Track dependency
         void serverStore.servers;
         if (serverListContainer && savedScrollTop > 0) {
           // Only restore if significantly different (prevents minor drift)
           if (Math.abs(serverListContainer.scrollTop - savedScrollTop) > 10) {
             serverListContainer.scrollTop = savedScrollTop;
           }
         }
       });
       ```

    4. Remove the old window-based scroll tracking (lastScrollY, rafId, window listeners)

    5. Wrap the server tiles in a scrollable container:
       ```svelte
       <div
         bind:this={serverListContainer}
         class="overflow-auto max-h-[calc(100vh-200px)]"
       >
         {#each serverStore.servers as server (server.profile_id)}
           <ServerTile {server} />
         {/each}
       </div>
       ```

    Key insights from research:
    - Container-scoped scrolling is more reliable than window scrolling
    - $effect.pre runs before DOM updates, $effect runs after
    - The existing reconcileArray in serverStore already minimizes DOM churn
    - Keyed each blocks (server.profile_id) preserve item identity

    Important: Ensure ServerTile heights are stable (no async content loading that changes height).
  </action>
  <verify>cd frontend && npm run check && npm run lint</verify>
  <done>Scroll preservation uses container-scoped $effect.pre/$effect pattern</done>
</task>

<task type="auto">
  <name>Task 2: Add CSS containment for layout stability</name>
  <files>frontend/src/routes/servers/+page.svelte</files>
  <action>
    Add CSS containment hints to prevent layout thrashing:

    1. On the server tiles container, add:
       ```svelte
       <div
         bind:this={serverListContainer}
         class="overflow-auto max-h-[calc(100vh-200px)]"
         style="contain: layout;"
       >
       ```

    2. On each ServerTile wrapper (or in ServerTile.svelte itself), ensure stable height:
       - Use `min-h-[...]` to set minimum height
       - Avoid content that loads asynchronously and changes height

    Note: `contain: layout` tells the browser that layout changes inside
    this container won't affect elements outside it, enabling optimizations.
  </action>
  <verify>cd frontend && npm run check</verify>
  <done>CSS containment added to prevent layout thrashing</done>
</task>

<task type="auto">
  <name>Task 3: Clean up obsolete scroll handling code</name>
  <files>frontend/src/routes/servers/+page.svelte</files>
  <action>
    Remove any remaining obsolete scroll handling:

    1. Remove `lastScrollY` variable if still present
    2. Remove `rafId` variable if still present
    3. Remove window scroll event listener in onMount
    4. Remove the double-RAF $effect that was restoring window.scrollY
    5. Clean up any cancelAnimationFrame calls

    The new pattern should be simpler:
    - No window listeners
    - No requestAnimationFrame
    - Just $effect.pre + $effect on the container
  </action>
  <verify>cd frontend && npm run check && npm run lint</verify>
  <done>Obsolete scroll handling code removed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd frontend && npm run check` passes
- [ ] `cd frontend && npm run lint` passes
- [ ] Manual: Open /servers with multiple running servers
- [ ] Manual: Scroll down in the list
- [ ] Manual: Wait for 5-second polling update (watch network tab)
- [ ] Manual: Verify scroll position doesn't jump
- [ ] Manual: Repeat 3-4 polling cycles to confirm stability
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Scroll position preserved across multiple polling cycles
- No requestAnimationFrame or window scroll listeners in code
- Layout remains stable during metric updates
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-panel-redesign/02-04-SUMMARY.md`
</output>
