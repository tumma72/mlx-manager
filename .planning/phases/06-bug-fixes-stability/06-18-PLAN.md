---
phase: 06-bug-fixes-stability
plan: 18
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/mlx_manager/routers/models.py
  - backend/mlx_manager/utils/model_detection.py
  - frontend/src/lib/stores/models.svelte.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "No 404 console errors when browsing models (backend returns 204 for missing configs)"
    - "Tool-use badge appears on known tool-capable model families (Qwen, GLM, MiniMax, DeepSeek, Hermes)"
    - "Model family detection works even without HuggingFace tags"
  artifacts:
    - path: "backend/mlx_manager/routers/models.py"
      provides: "204 No Content response for missing model configs"
      contains: "status_code=204"
    - path: "backend/mlx_manager/utils/model_detection.py"
      provides: "Model family allowlist for tool-use detection"
      contains: "TOOL_CAPABLE_FAMILIES"
    - path: "frontend/src/lib/stores/models.svelte.ts"
      provides: "Model family allowlist for frontend tool-use detection"
      contains: "TOOL_CAPABLE_FAMILIES"
  key_links:
    - from: "backend/mlx_manager/routers/models.py"
      to: "frontend/src/lib/stores/models.svelte.ts"
      via: "API returns 204 instead of 404, frontend handles gracefully"
      pattern: "status_code=204"
---

<objective>
Fix tool-use badge reliability by adding model family allowlist detection and eliminate browser console 404 errors by returning 204 for missing model configs.

Purpose: Two issues addressed:
1. Browser console shows 404 errors for every model when browsing because config.json fetches fail and network layer logs the error before JS catches it.
2. Tool-use badge unreliable because detection only uses explicit HuggingFace tags which many model creators don't set. Known tool-capable families (Qwen, GLM, MiniMax, DeepSeek, Hermes) should show badge regardless.

Output: Clean console when browsing models, reliable tool-use badge on known capable model families.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-bug-fixes-stability/06-gap-closure-UAT.md (gap definition)
@backend/mlx_manager/routers/models.py (get_model_config endpoint at line 278)
@backend/mlx_manager/utils/model_detection.py (detect_tool_use function at line 343)
@frontend/src/lib/stores/models.svelte.ts (TOOL_USE_PATTERNS at line 92, fetchConfig at line 166)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Return 204 instead of 404 for missing model configs</name>
  <files>backend/mlx_manager/routers/models.py</files>
  <action>
    Modify the get_model_config endpoint to return 204 No Content instead of 404 when
    config is not found. This prevents browser console from logging network errors.

    Update the endpoint at line 278-311:

    Replace the final HTTPException:
    ```python
    raise HTTPException(status_code=404, detail="Config not found")
    ```

    With a 204 No Content response:
    ```python
    from fastapi import Response

    # In the endpoint function, replace the raise with:
    return Response(status_code=204)
    ```

    The full updated endpoint should look like:
    ```python
    @router.get("/config/{model_id:path}")
    async def get_model_config(
        current_user: Annotated[User, Depends(get_current_user)],
        model_id: str,
        tags: str | None = Query(None, description="Comma-separated HuggingFace tags"),
    ):
        """Get model characteristics from config.json.

        For local models: reads from HuggingFace cache.
        For remote models: fetches via HuggingFace resolve API.

        Returns:
            ModelCharacteristics with architecture, context window, quantization, etc.
            204 No Content if config is not available.
        """
        from fastapi import Response
        from mlx_manager.services.hf_api import fetch_remote_config
        from mlx_manager.utils.model_detection import (
            extract_characteristics,
            extract_characteristics_from_model,
        )

        # Parse tags into list
        tag_list = tags.split(",") if tags else None

        # Try local first
        chars = extract_characteristics_from_model(model_id, tags=tag_list)
        if chars:
            return chars

        # Fetch remote
        config = await fetch_remote_config(model_id)
        if config:
            return extract_characteristics(config, tags=tag_list)

        # Return 204 No Content instead of 404 to avoid browser console errors
        return Response(status_code=204)
    ```

    Import Response at the top of the file if not already imported.
  </action>
  <verify>
    Run `cd /Users/atomasini/Development/mlx-manager/backend && source .venv/bin/activate && python -c "from mlx_manager.routers.models import router; print('Import OK')"` to verify no syntax errors.
    Grep for "status_code=204" in models.py to confirm the change.
  </verify>
  <done>
    Backend returns 204 No Content for missing model configs instead of 404,
    eliminating browser console errors during model browsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add model family allowlist for backend tool-use detection</name>
  <files>backend/mlx_manager/utils/model_detection.py</files>
  <action>
    Update detect_tool_use() to include a model family allowlist that marks known
    tool-capable model families as supporting tool-use regardless of HuggingFace tags.

    1. Add a constant for tool-capable model families (around line 50, after ARCHITECTURE_FAMILIES):
       ```python
       # Model families that support tool-use/function-calling by default
       # These families have native tool-use support regardless of HuggingFace tags
       TOOL_CAPABLE_FAMILIES: set[str] = {
           "qwen",      # Qwen models have native function calling
           "qwen2",
           "qwen3",
           "glm",       # GLM-4 family supports tool use
           "chatglm",
           "minimax",   # MiniMax models support tool use
           "deepseek",  # DeepSeek family supports function calling
           "deepseek_v3",
           "hermes",    # Hermes models fine-tuned for tool use
           "command",   # Cohere Command-R supports tools
           "cohere",
           "mistral",   # Mistral-Instruct models support function calling
       }
       ```

    2. Update detect_tool_use() function (starting at line 343) to check model family:

       Add model family check after tag-based detection but before config-based detection:
       ```python
       def detect_tool_use(config: dict[str, Any], tags: list[str] | None = None) -> bool:
           """
           Detect if a model supports tool-use / function-calling.

           Uses three detection strategies:
           1. Tag-based (primary): Check HuggingFace tags for tool-use indicators
           2. Family-based (secondary): Check if model_type matches known tool-capable families
           3. Config-based (fallback): Check config.json for tool_call_parser

           Args:
               config: Parsed config.json dictionary
               tags: Optional list of HuggingFace tags for the model

           Returns:
               True if model supports tool-use, False otherwise
           """
           # Tag-based detection (primary)
           if tags:
               tags_lower = [tag.lower() for tag in tags]
               tool_indicators = [
                   "tool-use",
                   "tool_use",
                   "function-calling",
                   "function_calling",
                   "tool-calling",
                   "tools",
               ]
               if any(indicator in tag for tag in tags_lower for indicator in tool_indicators):
                   return True

           # Family-based detection (secondary) - check model_type against known families
           model_type = config.get("model_type", "").lower()
           if model_type in TOOL_CAPABLE_FAMILIES:
               return True
           # Also check for partial matches (e.g., "qwen2_vl" contains "qwen")
           for family in TOOL_CAPABLE_FAMILIES:
               if family in model_type:
                   return True

           # Config-based detection (fallback)
           # Check for tool_call_parser in config (some models have this)
           if "tool_call_parser" in config:
               return True

           return False
       ```

    3. Remove the overly complex nested check at the end of the old function (the part
       checking tool_capable_types with nested string value search).
  </action>
  <verify>
    Run `cd /Users/atomasini/Development/mlx-manager/backend && source .venv/bin/activate && python -c "from mlx_manager.utils.model_detection import detect_tool_use, TOOL_CAPABLE_FAMILIES; print(f'Families: {TOOL_CAPABLE_FAMILIES}')"` to verify import works.
    Grep for "TOOL_CAPABLE_FAMILIES" to confirm constant exists.
  </verify>
  <done>
    Backend detect_tool_use() uses model family allowlist to reliably detect
    tool-capable models (Qwen, GLM, MiniMax, DeepSeek, Hermes, Mistral-Instruct).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add model family allowlist for frontend tool-use detection</name>
  <files>frontend/src/lib/stores/models.svelte.ts</files>
  <action>
    Update the frontend parseCharacteristicsFromName() function to include model family
    allowlist for tool-use detection, matching the backend implementation.

    1. Add a constant for tool-capable model families (after TOOL_USE_PATTERNS around line 97):
       ```typescript
       /**
        * Model families known to support tool-use/function-calling.
        * Used when HuggingFace tags don't indicate tool support.
        */
       const TOOL_CAPABLE_FAMILIES = new Set([
           "Qwen",      // Qwen models have native function calling
           "GLM",       // GLM-4 family supports tool use
           "MiniMax",   // MiniMax models support tool use
           "DeepSeek",  // DeepSeek family supports function calling
           "Hermes",    // Hermes models fine-tuned for tool use
           "Command-R", // Cohere Command-R supports tools
           "Mistral",   // Mistral-Instruct models support function calling
       ]);
       ```

    2. Update parseCharacteristicsFromName() (starting at line 103) to check the family
       after detecting architecture:

       After the architecture detection loop, add:
       ```typescript
       // Detect tool-use from tags (existing code)
       for (const pattern of TOOL_USE_PATTERNS) {
           if (pattern.test(searchText)) {
               characteristics.is_tool_use = true;
               break;
           }
       }

       // Also check if detected architecture family is tool-capable
       if (!characteristics.is_tool_use && characteristics.architecture_family) {
           if (TOOL_CAPABLE_FAMILIES.has(characteristics.architecture_family)) {
               characteristics.is_tool_use = true;
           }
       }
       ```

       The full updated section should be:
       ```typescript
       // Detect tool-use (check tags first, then model family)
       for (const pattern of TOOL_USE_PATTERNS) {
           if (pattern.test(searchText)) {
               characteristics.is_tool_use = true;
               break;
           }
       }

       // Fall back to model family check for known tool-capable families
       if (!characteristics.is_tool_use && characteristics.architecture_family) {
           if (TOOL_CAPABLE_FAMILIES.has(characteristics.architecture_family)) {
               characteristics.is_tool_use = true;
           }
       }

       return characteristics;
       ```
  </action>
  <verify>
    Run `cd /Users/atomasini/Development/mlx-manager/frontend && npm run check` to verify no type errors.
    Grep for "TOOL_CAPABLE_FAMILIES" in models.svelte.ts to confirm constant exists.
  </verify>
  <done>
    Frontend parseCharacteristicsFromName() uses model family allowlist to reliably
    detect tool-capable models in fallback parsing path.
  </done>
</task>

</tasks>

<verification>
- Backend returns 204 for missing configs (no 404)
- TOOL_CAPABLE_FAMILIES constant exists in both backend and frontend
- detect_tool_use() in backend checks model family after tags
- parseCharacteristicsFromName() in frontend checks family after tags
- `npm run check` passes in frontend
- Backend imports work without errors
</verification>

<success_criteria>
- No 404 errors in browser console when browsing models
- Qwen3 models show tool-use badge (even without explicit tags)
- GLM-4 models show tool-use badge
- MiniMax models show tool-use badge
- DeepSeek models show tool-use badge
- Models with explicit tool-use tags still detected correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-bug-fixes-stability/06-18-SUMMARY.md`
</output>
