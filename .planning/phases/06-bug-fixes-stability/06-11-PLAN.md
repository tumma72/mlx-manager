---
phase: 06-bug-fixes-stability
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/mlx_manager/routers/chat.py
  - frontend/src/lib/api/types.ts
  - frontend/src/lib/api/client.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When tools enabled, tools array is forwarded to mlx-openai-server"
    - "Model tool_calls in streaming response are parsed and emitted as SSE events"
    - "finish_reason tool_calls triggers a tool_calls_done SSE event"
    - "Frontend has typed mcp.listTools() and mcp.executeTool() API methods"
  artifacts:
    - path: "backend/mlx_manager/routers/chat.py"
      provides: "ChatRequest with tools/tool_choice fields, tool_call SSE emission"
      contains: "tool_calls"
    - path: "frontend/src/lib/api/types.ts"
      provides: "ToolCall and ToolDefinition interfaces"
      contains: "ToolCall"
    - path: "frontend/src/lib/api/client.ts"
      provides: "MCP API client (listTools, executeTool)"
      contains: "mcp"
  key_links:
    - from: "backend/mlx_manager/routers/chat.py"
      to: "mlx-openai-server"
      via: "tools and tool_choice forwarded in JSON body"
      pattern: "request\\.tools"
    - from: "frontend/src/lib/api/client.ts"
      to: "backend/mlx_manager/routers/mcp.py"
      via: "fetch to /api/mcp/tools and /api/mcp/execute"
      pattern: "mcp/(tools|execute)"
---

<objective>
Add tool forwarding to the backend chat proxy and create frontend API types/client for MCP tools. The backend must forward tools to mlx-openai-server and parse tool_calls from the streaming response. The frontend needs typed API methods to list and execute tools.

Purpose: Provide the infrastructure layer for tool-use chat (the UI integration is in plan 06-13)
Output: Backend forwards tools, emits tool_call SSE events; frontend has mcp client and ToolCall/ToolDefinition types
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@backend/mlx_manager/routers/chat.py
@backend/mlx_manager/routers/mcp.py
@frontend/src/lib/api/client.ts
@frontend/src/lib/api/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend chat proxy tool forwarding</name>
  <files>backend/mlx_manager/routers/chat.py</files>
  <action>
    Modify the chat completions endpoint to forward tools and parse tool_calls from the stream.

    **1. Extend ChatRequest model (line 20-24):**
    Add two optional fields after `messages`:
    ```python
    class ChatRequest(BaseModel):
        """Chat completion request."""
        profile_id: int
        messages: list[dict]  # OpenAI-compatible message format
        tools: list[dict] | None = None  # OpenAI function definitions array
        tool_choice: str | None = None   # "auto", "none", or specific function
    ```

    **2. Modify the JSON body in generate() (lines 67-71):**
    Replace the inline dict with a variable so tools can be conditionally added:
    ```python
    body: dict = {
        "model": profile.model_path,
        "messages": request.messages,
        "stream": True,
    }
    if request.tools:
        body["tools"] = request.tools
        body["tool_choice"] = request.tool_choice or "auto"
    ```
    Then use `json=body` in `client.stream("POST", server_url, json=body)`.

    **3. Add tool_calls parsing in the SSE loop (after line 90, inside the `delta` processing):**
    After `content = delta.get("content", "")` and `reasoning = delta.get("reasoning_content", "")`, add:
    ```python
    # Handle tool calls from model
    tool_calls = delta.get("tool_calls")
    if tool_calls:
        for tc in tool_calls:
            tool_data = {
                "type": "tool_call",
                "tool_call": tc,  # {index, id, function: {name, arguments}}
            }
            yield f"data: {json.dumps(tool_data)}\n\n"
    ```

    **4. Add finish_reason check (inside the same try block, after processing delta):**
    After the existing content/thinking handling, check finish_reason:
    ```python
    # Check finish_reason for tool_calls completion
    finish_reason = data.get("choices", [{}])[0].get("finish_reason")
    if finish_reason == "tool_calls":
        yield f"data: {json.dumps({'type': 'tool_calls_done'})}\n\n"
    ```

    Place this AFTER all content/thinking processing (after the `else: # Regular response content` block ends) but still inside the `try: data = json.loads(data_str)` block.
  </action>
  <verify>
    Run: `cd /Users/atomasini/Development/mlx-manager/backend && source .venv/bin/activate && ruff check mlx_manager/routers/chat.py && ruff format --check mlx_manager/routers/chat.py && mypy mlx_manager/routers/chat.py --ignore-missing-imports`
  </verify>
  <done>
    - ChatRequest accepts optional tools and tool_choice fields
    - When tools present, they are forwarded in the JSON body to mlx-openai-server
    - delta.tool_calls are parsed and emitted as type:"tool_call" SSE events
    - finish_reason "tool_calls" triggers type:"tool_calls_done" SSE event
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend types and MCP API client</name>
  <files>
    frontend/src/lib/api/types.ts
    frontend/src/lib/api/client.ts
  </files>
  <action>
    **1. Add tool types to types.ts (after the Attachment interface, line 248):**

    ```typescript
    // Tool-use types for MCP integration
    export interface ToolCall {
      id: string;
      index?: number;
      function: {
        name: string;
        arguments: string; // JSON-encoded string
      };
    }

    export interface ToolDefinition {
      type: "function";
      function: {
        name: string;
        description: string;
        parameters: Record<string, unknown>;
      };
    }
    ```

    **2. Add MCP client to client.ts (after the `system` export, before the `export { ApiError }` line):**

    Import the ToolDefinition type at the top of client.ts (add to the existing type imports from "./types"):
    ```typescript
    import type {
      // ... existing imports ...
      ToolDefinition,
    } from "./types";
    ```

    Then add the mcp export:
    ```typescript
    // MCP Tools API
    export const mcp = {
      listTools: async (): Promise<ToolDefinition[]> => {
        const res = await fetch(`${API_BASE}/mcp/tools`, {
          headers: getAuthHeaders(),
        });
        return handleResponse(res);
      },

      executeTool: async (
        name: string,
        args: Record<string, unknown>,
      ): Promise<Record<string, unknown>> => {
        const res = await fetch(`${API_BASE}/mcp/execute`, {
          method: "POST",
          headers: getAuthHeaders(),
          body: JSON.stringify({ name, arguments: args }),
        });
        return handleResponse(res);
      },
    };
    ```

    Note: `getAuthHeaders()` is already a module-scoped function in client.ts (line 39) and handles Content-Type. The `handleResponse` utility handles 401 redirect and error parsing.
  </action>
  <verify>
    Run: `cd /Users/atomasini/Development/mlx-manager/frontend && npm run check && npm run lint`
  </verify>
  <done>
    - ToolCall and ToolDefinition interfaces exported from types.ts
    - mcp.listTools() calls GET /api/mcp/tools with auth headers
    - mcp.executeTool(name, args) calls POST /api/mcp/execute with auth headers
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
- `cd /Users/atomasini/Development/mlx-manager/backend && source .venv/bin/activate && ruff check . && mypy mlx_manager --ignore-missing-imports`
- `cd /Users/atomasini/Development/mlx-manager/frontend && npm run check && npm run lint`
- grep confirms: `tools` in ChatRequest, `tool_call` in SSE emission, `mcp` export in client.ts, `ToolCall` in types.ts
</verification>

<success_criteria>
- ChatRequest model has tools and tool_choice optional fields
- Backend forwards tools to mlx-openai-server when present
- Backend emits "tool_call" SSE events for each tool call chunk
- Backend emits "tool_calls_done" when finish_reason is "tool_calls"
- Frontend ToolCall and ToolDefinition types are defined and exported
- Frontend mcp.listTools() and mcp.executeTool() are working API methods
- All linting, type checking, and formatting pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-bug-fixes-stability/06-11-SUMMARY.md`
</output>
