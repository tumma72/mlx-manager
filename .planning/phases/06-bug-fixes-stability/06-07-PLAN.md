---
phase: 06-bug-fixes-stability
plan: 07
type: execute
wave: 2
depends_on: []
files_modified:
  - backend/mlx_manager/routers/mcp.py
  - backend/mlx_manager/main.py
  - backend/tests/test_mcp.py
autonomous: true

must_haves:
  truths:
    - "MCP mock tools endpoint serves tool definitions (get_weather, calculate)"
    - "Tool execution endpoint processes tool calls and returns results"
    - "Models with tool_call_parser set can use these mock tools via chat"
    - "Tool results are formatted as proper OpenAI tool_call responses"
  artifacts:
    - path: "backend/mlx_manager/routers/mcp.py"
      provides: "MCP mock tool definitions and execution"
      min_lines: 80
      exports: ["router"]
    - path: "backend/tests/test_mcp.py"
      provides: "Tests for MCP mock endpoints"
      min_lines: 30
  key_links:
    - from: "backend/mlx_manager/routers/mcp.py"
      to: "backend/mlx_manager/main.py"
      via: "router registration"
      pattern: "include_router.*mcp"
---

<objective>
Create a backend MCP mock service with get_weather and calculator tools that models can invoke via tool calling.

Purpose: Enable testing of tool-use capable models by providing simple, deterministic mock tools. Users can chat with a model that has tool_call_parser configured and verify it correctly invokes tools and uses results.
Output: MCP mock router with tool definitions and execution endpoints; tests for the endpoints.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/mlx_manager/main.py
@backend/mlx_manager/routers/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP mock router with tool definitions and execution</name>
  <files>
    backend/mlx_manager/routers/mcp.py
    backend/mlx_manager/main.py
  </files>
  <action>
    1. Create `backend/mlx_manager/routers/mcp.py` with mock tool implementations:

    The router should provide:
    - `GET /api/mcp/tools` — returns tool definitions in OpenAI function-calling format
    - `POST /api/mcp/execute` — executes a tool call and returns the result

    **Tool definitions** (OpenAI format):
    - `get_weather`: Takes `location` (required string) and `unit` (optional, "celsius"|"fahrenheit"). Returns deterministic mock weather based on location hash (temperature, condition, humidity).
    - `calculate`: Takes `expression` (required string). Performs safe arithmetic using Python's `ast.literal_eval` on a pre-parsed AST (NOT using eval). Use the `ast` module to parse the expression and walk the AST tree, only allowing numeric literals and basic arithmetic operators (+, -, *, /, **). Reject anything else as unsafe.

    **Safe calculator implementation using ast:**
    ```python
    import ast
    import operator

    SAFE_OPERATORS = {
        ast.Add: operator.add,
        ast.Sub: operator.sub,
        ast.Mult: operator.mul,
        ast.Div: operator.truediv,
        ast.Pow: operator.pow,
        ast.USub: operator.neg,
    }

    def safe_eval_expr(node):
        """Safely evaluate an arithmetic expression AST node."""
        if isinstance(node, ast.Expression):
            return safe_eval_expr(node.body)
        elif isinstance(node, ast.Constant) and isinstance(node.value, (int, float)):
            return node.value
        elif isinstance(node, ast.BinOp) and type(node.op) in SAFE_OPERATORS:
            left = safe_eval_expr(node.left)
            right = safe_eval_expr(node.right)
            return SAFE_OPERATORS[type(node.op)](left, right)
        elif isinstance(node, ast.UnaryOp) and type(node.op) in SAFE_OPERATORS:
            return SAFE_OPERATORS[type(node.op)](safe_eval_expr(node.operand))
        else:
            raise ValueError(f"Unsupported expression element: {ast.dump(node)}")

    def execute_calculate(arguments):
        expression = arguments.get("expression", "")
        try:
            tree = ast.parse(expression, mode="eval")
            result = safe_eval_expr(tree)
            return {"expression": expression, "result": result}
        except Exception as e:
            return {"error": f"Calculation failed: {str(e)}"}
    ```

    **Mock weather** uses deterministic values based on `hash(location.lower()) % N` for temperature, condition, and humidity.

    Both endpoints require authentication via `Depends(get_current_user)`.

    2. Register the router in `main.py`. Add the import and `app.include_router(mcp.router)` alongside existing router registrations.
  </action>
  <verify>
    Run `cd backend && ruff check . && ruff format --check . && mypy mlx_manager` — no errors.
    Test endpoints:
    - `GET /api/mcp/tools` — returns 2 tool definitions
    - `POST /api/mcp/execute {"name":"get_weather","arguments":{"location":"Tokyo"}}` — returns weather data
    - `POST /api/mcp/execute {"name":"calculate","arguments":{"expression":"2+3*4"}}` — returns result: 14
    - Calculator rejects unsafe input like "import os" or "__import__('os')"
  </verify>
  <done>MCP mock router registered and serving tool definitions. get_weather returns deterministic mock data. calculate uses safe AST-based evaluation (no code injection possible). Both endpoints require authentication.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for MCP mock endpoints</name>
  <files>backend/tests/test_mcp.py</files>
  <action>
    Create tests for the MCP mock endpoints following the existing test patterns in the project:

    Test cases to cover:
    1. `test_list_tools` — GET /api/mcp/tools returns 200 with 2 tool definitions
    2. `test_execute_weather` — POST with get_weather returns temperature, condition, unit
    3. `test_execute_weather_default_unit` — Defaults to celsius when unit not specified
    4. `test_execute_calculate` — POST with calculate returns correct arithmetic result (2+3*4=14)
    5. `test_execute_calculate_division` — Tests division (10/3 returns float)
    6. `test_execute_calculate_invalid` — Rejects unsafe expressions (returns error, not crash)
    7. `test_execute_unknown_tool` — Unknown tool name returns error field
    8. `test_tools_require_auth` — Unauthenticated request to /api/mcp/tools returns 401

    Use the existing test fixtures (`auth_client` for authenticated requests, `client` for unauthenticated). Check existing test files (e.g., test_profiles.py) for the correct fixture patterns used in this project.

    All tests should be `@pytest.mark.asyncio` and use `AsyncClient`.
  </action>
  <verify>
    Run `cd backend && pytest tests/test_mcp.py -v` — all tests pass.
    Run `pytest -v` — full test suite passes (no regressions).
  </verify>
  <done>MCP mock endpoints have comprehensive tests covering: tool listing, weather execution (with units), calculator (valid, division, and invalid), unknown tool handling, and authentication requirement. All pass.</done>
</task>

</tasks>

<verification>
- `cd backend && ruff check . && ruff format --check . && mypy mlx_manager && pytest -v` all pass
- `/api/mcp/tools` returns 2 tool definitions in OpenAI format
- `/api/mcp/execute` processes tool calls correctly
- Calculator uses safe AST evaluation (rejects unsafe expressions)
- All endpoints require authentication
</verification>

<success_criteria>
- Two mock tools available: get_weather and calculate
- Tool definitions follow OpenAI function-calling format
- Execution is deterministic and safe (AST-based, no code injection)
- Authentication required for all MCP endpoints
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-bug-fixes-stability/06-07-SUMMARY.md`
</output>
