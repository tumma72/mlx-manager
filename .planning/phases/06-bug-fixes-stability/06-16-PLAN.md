---
phase: 06-bug-fixes-stability
plan: 16
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/components/ui/tool-call-bubble.svelte
  - frontend/src/lib/components/ui/index.ts
  - frontend/src/routes/(protected)/chat/+page.svelte
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Tool calls displayed in a collapsible panel (not inline markdown)"
    - "Panel shows 'Tool Calls: N' header with wrench icon"
    - "Expanded view shows tool name, arguments (code-formatted), and result"
    - "Multiple tool calls in one response grouped in single panel"
  artifacts:
    - path: "frontend/src/lib/components/ui/tool-call-bubble.svelte"
      provides: "Collapsible tool call display component"
      contains: "Collapsible"
    - path: "frontend/src/routes/(protected)/chat/+page.svelte"
      provides: "Structured tool call data separate from message content"
      contains: "ToolCallBubble"
  key_links:
    - from: "frontend/src/routes/(protected)/chat/+page.svelte"
      to: "frontend/src/lib/components/ui/tool-call-bubble.svelte"
      via: "import and render in message loop"
      pattern: "ToolCallBubble"
---

<objective>
Create a ToolCallBubble component following the ThinkingBubble pattern, and refactor tool call handling to store structured data separately from message content string.

Purpose: Tool calls currently render as bold markdown text (ugly, prominent). They should display in a collapsible panel like thinking blocks - compact header, expandable code-formatted details.

Output: ToolCallBubble component renders tool calls with collapsible UI. Tool data stored as structured metadata on messages, not concatenated into content string.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend/src/lib/components/ui/thinking-bubble.svelte (pattern to follow)
@frontend/src/routes/(protected)/chat/+page.svelte (tool call handling at lines 408-484, Message interface at line 11)
@frontend/src/lib/components/ui/index.ts (component exports)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ToolCallBubble component</name>
  <files>
    frontend/src/lib/components/ui/tool-call-bubble.svelte
    frontend/src/lib/components/ui/index.ts
  </files>
  <action>
    Create `frontend/src/lib/components/ui/tool-call-bubble.svelte` following ThinkingBubble pattern:

    ```svelte
    <script lang="ts">
        import { Collapsible } from 'bits-ui';
        import { ChevronDown, ChevronRight, Wrench } from 'lucide-svelte';

        interface ToolCallData {
            id: string;
            name: string;
            arguments: string;
            result?: string;
            error?: string;
        }

        interface Props {
            calls: ToolCallData[];
        }

        let { calls }: Props = $props();
        let expanded = $state(false);

        const label = $derived(
            calls.length === 1
                ? `Tool: ${calls[0].name}`
                : `Tool Calls: ${calls.length}`
        );

        function formatArgs(args: string): string {
            try {
                return JSON.stringify(JSON.parse(args), null, 2);
            } catch {
                return args;
            }
        }
    </script>

    <div class="my-2">
        <Collapsible.Root bind:open={expanded}>
            <Collapsible.Trigger
                class="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors"
            >
                {#if expanded}
                    <ChevronDown class="w-4 h-4" />
                {:else}
                    <ChevronRight class="w-4 h-4" />
                {/if}
                <Wrench class="w-4 h-4" />
                <span>{label}</span>
            </Collapsible.Trigger>
            <Collapsible.Content>
                <div class="mt-2 pl-6 border-l-2 border-amber-300 dark:border-amber-700 space-y-3">
                    {#each calls as call (call.id)}
                        <div class="text-sm">
                            <div class="font-medium text-foreground">{call.name}</div>
                            <pre class="mt-1 p-2 rounded bg-muted text-xs font-mono overflow-x-auto whitespace-pre-wrap">{formatArgs(call.arguments)}</pre>
                            {#if call.result}
                                <div class="mt-1 text-xs text-muted-foreground">Result:</div>
                                <pre class="mt-0.5 p-2 rounded bg-green-50 dark:bg-green-950/30 text-xs font-mono overflow-x-auto whitespace-pre-wrap text-green-700 dark:text-green-300">{call.result}</pre>
                            {/if}
                            {#if call.error}
                                <div class="mt-1 text-xs text-red-600 dark:text-red-400">{call.error}</div>
                            {/if}
                        </div>
                    {/each}
                </div>
            </Collapsible.Content>
        </Collapsible.Root>
    </div>
    ```

    Then add the export to `frontend/src/lib/components/ui/index.ts`:
    ```typescript
    export { default as ToolCallBubble } from "./tool-call-bubble.svelte";
    ```
  </action>
  <verify>
    Run `cd /Users/atomasini/Development/mlx-manager/frontend && npm run check` to verify no type errors.
    Confirm file exists at frontend/src/lib/components/ui/tool-call-bubble.svelte.
    Grep index.ts for "ToolCallBubble" to confirm export.
  </verify>
  <done>
    ToolCallBubble component created with Collapsible UI, wrench icon, code-formatted
    arguments, and color-coded results. Exported from ui/index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor chat to use structured tool call data and ToolCallBubble</name>
  <files>frontend/src/routes/(protected)/chat/+page.svelte</files>
  <action>
    Refactor the chat page to store tool calls as structured data and render via ToolCallBubble:

    1. Update the Message interface to include optional toolCalls:
       ```typescript
       interface ToolCallData {
           id: string;
           name: string;
           arguments: string;
           result?: string;
           error?: string;
       }

       interface Message {
           role: 'user' | 'assistant';
           content: string | ContentPart[];
           toolCalls?: ToolCallData[];
       }
       ```

    2. Import ToolCallBubble in the component imports:
       ```typescript
       import { Card, Button, Select, Markdown, ThinkingBubble, ErrorMessage, ToolCallBubble } from '$components/ui';
       ```

    3. Add a reactive variable for streaming tool calls:
       ```typescript
       let streamingToolCalls = $state<ToolCallData[]>([]);
       ```

    4. In sendWithRetry(), replace the tool call display logic (lines 411-445) to build
       structured data instead of concatenating markdown strings:

       Replace:
       ```typescript
       // Display tool calls in assistant message
       for (const toolCall of currentResult.toolCalls) {
           const toolCallText = `\n\n---\n**Tool call:** \`${toolCall.name}(${toolCall.arguments})\`\n`;
           assistantContent += toolCallText;
           streamingResponse = assistantContent;
           // ... execute and append result as markdown ...
       }
       ```

       With:
       ```typescript
       // Execute tool calls and store structured results
       for (const toolCall of currentResult.toolCalls) {
           const callData: ToolCallData = {
               id: toolCall.id,
               name: toolCall.name,
               arguments: toolCall.arguments,
           };

           try {
               const parsedArgs = JSON.parse(toolCall.arguments);
               const toolResult = await mcp.executeTool(toolCall.name, parsedArgs);
               callData.result = JSON.stringify(toolResult);
           } catch {
               callData.error = 'Tool execution failed';
           }

           streamingToolCalls = [...streamingToolCalls, callData];

           // Add assistant tool_calls message and tool result to apiMessages
           apiMessages.push({
               role: 'assistant',
               content: '',
               tool_calls: [{
                   id: toolCall.id,
                   type: 'function',
                   function: { name: toolCall.name, arguments: toolCall.arguments }
               }]
           } as any);
           apiMessages.push({
               role: 'tool',
               tool_call_id: toolCall.id,
               content: callData.result || callData.error || ''
           } as any);
       }
       ```

    5. When finalizing the message (around line 487-491), include toolCalls in the message:
       ```typescript
       if (streamingResponse || streamingThinking || streamingToolCalls.length > 0) {
           const finalContent = streamingThinking
               ? `<think>${streamingThinking}</think>${streamingResponse}`
               : streamingResponse;
           messages.push({
               role: 'assistant',
               content: finalContent,
               toolCalls: streamingToolCalls.length > 0 ? [...streamingToolCalls] : undefined
           });
       }
       ```

    6. Reset streamingToolCalls alongside other streaming state (around line 559):
       ```typescript
       streamingToolCalls = [];
       ```

    7. In the template, render ToolCallBubble AFTER ThinkingBubble and BEFORE Markdown
       in the assistant message rendering (around lines 725-730):
       ```svelte
       {#if message.role === 'assistant'}
           {@const parsed = parseThinking(message.content)}
           {#if parsed.thinking}
               <ThinkingBubble content={parsed.thinking} />
           {/if}
           {#if message.toolCalls && message.toolCalls.length > 0}
               <ToolCallBubble calls={message.toolCalls} />
           {/if}
           <Markdown content={parsed.response} />
       {:else}
       ```

    8. Also show streaming tool calls in the loading section (around line 756-767):
       After the streaming thinking bubble and before the streaming response markdown, add:
       ```svelte
       {#if streamingToolCalls.length > 0}
           <ToolCallBubble calls={streamingToolCalls} />
       {/if}
       ```

    9. Remove the `assistantContent += toolCallText` and `assistantContent += resultText`
       markdown concatenation entirely. The assistantContent variable should only accumulate
       actual model response text from currentResult.content, NOT tool call formatting.
  </action>
  <verify>
    Run `cd /Users/atomasini/Development/mlx-manager/frontend && npm run check` to verify no type errors.
    Grep for "Tool call:" in +page.svelte - should NOT appear (old markdown format removed).
    Grep for "ToolCallBubble" in +page.svelte - should appear in imports and template.
    Grep for "streamingToolCalls" - should appear in state declaration, reset, and template.
  </verify>
  <done>
    Tool calls stored as structured ToolCallData[] on Message objects. Rendered via
    ToolCallBubble component with collapsible UI. No more markdown concatenation for
    tool call display. Streaming tool calls shown during execution.
  </done>
</task>

</tasks>

<verification>
- `npm run check` passes in frontend
- ToolCallBubble component exists and is exported
- No markdown tool call text concatenation in sendWithRetry
- Tool calls rendered via ToolCallBubble in both stored messages and streaming state
- Message interface includes optional toolCalls field
</verification>

<success_criteria>
- Tool calls display in collapsible panel with wrench icon and "Tool Calls: N" header
- Expanded view shows tool name, formatted arguments, and color-coded results
- Multiple tool calls grouped in single panel per response
- Streaming tool calls visible during execution
- No bold markdown text for tool calls
</success_criteria>

<output>
After completion, create `.planning/phases/06-bug-fixes-stability/06-16-SUMMARY.md`
</output>
