---
phase: 10-dual-protocol-cloud-fallback
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/mlx_manager/models.py
  - backend/mlx_manager/database.py
  - backend/tests/test_cloud_models.py
autonomous: true

must_haves:
  truths:
    - "BackendMapping table stores model pattern to backend routing rules"
    - "CloudCredential table stores encrypted API keys per backend type"
    - "Backend types include LOCAL, OPENAI, ANTHROPIC"
    - "Fallback backend is optional nullable field"
  artifacts:
    - path: "backend/mlx_manager/models.py"
      provides: "BackendMapping and CloudCredential SQLModel tables"
      contains: "class BackendMapping"
    - path: "backend/tests/test_cloud_models.py"
      provides: "Database model tests"
      min_lines: 40
  key_links:
    - from: "models.py"
      to: "database.py"
      via: "SQLModel table registration"
      pattern: "table=True"
---

<objective>
Add database models for backend routing configuration and cloud API credentials.

Purpose: Enable persistent storage of model-to-backend mappings and encrypted cloud API keys.
Output: BackendMapping and CloudCredential SQLModel tables with CRUD support.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-dual-protocol-cloud-fallback/10-RESEARCH.md
@backend/mlx_manager/models.py
@backend/mlx_manager/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend routing database models</name>
  <files>backend/mlx_manager/models.py</files>
  <action>
Add the following models to models.py (after existing models):

1. BackendType enum:
```python
class BackendType(str, Enum):
    """Backend types for routing."""
    LOCAL = "local"
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
```

2. BackendMapping model:
```python
class BackendMapping(SQLModel, table=True):
    """Maps model patterns to backends with fallback configuration."""

    __tablename__ = "backend_mappings"

    id: int | None = Field(default=None, primary_key=True)
    model_pattern: str = Field(index=True)  # e.g., "gpt-*" or exact model name
    backend_type: BackendType
    backend_model: str | None = None  # Override model name for cloud (e.g., map local to gpt-4)
    fallback_backend: BackendType | None = None  # Optional fallback on failure
    priority: int = Field(default=0)  # Higher = checked first for pattern matching
    enabled: bool = Field(default=True)
    created_at: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))
```

3. CloudCredential model:
```python
class CloudCredential(SQLModel, table=True):
    """Encrypted cloud API credentials."""

    __tablename__ = "cloud_credentials"

    id: int | None = Field(default=None, primary_key=True)
    backend_type: BackendType = Field(unique=True)  # One credential per backend type
    encrypted_api_key: str  # Encrypted with AuthLib (Phase 11 will add encryption)
    base_url: str | None = None  # Override default API URL (for Azure OpenAI, proxies)
    created_at: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))
```

4. Response/Create schemas:
```python
class BackendMappingCreate(SQLModel):
    """Schema for creating a backend mapping."""
    model_pattern: str
    backend_type: BackendType
    backend_model: str | None = None
    fallback_backend: BackendType | None = None
    priority: int = 0

class BackendMappingResponse(SQLModel):
    """Response model for backend mapping."""
    id: int
    model_pattern: str
    backend_type: BackendType
    backend_model: str | None
    fallback_backend: BackendType | None
    priority: int
    enabled: bool

class CloudCredentialCreate(SQLModel):
    """Schema for creating cloud credentials."""
    backend_type: BackendType
    api_key: str  # Plain text - will be encrypted before storage
    base_url: str | None = None

class CloudCredentialResponse(SQLModel):
    """Response model (no API key exposed)."""
    id: int
    backend_type: BackendType
    base_url: str | None
    created_at: datetime
```
  </action>
  <verify>
cd /Users/atomasini/Development/mlx-manager/backend && python -c "
from mlx_manager.models import BackendType, BackendMapping, CloudCredential, BackendMappingCreate
print(f'BackendType values: {[b.value for b in BackendType]}')
mapping = BackendMappingCreate(model_pattern='gpt-*', backend_type=BackendType.OPENAI)
print(f'Mapping created: pattern={mapping.model_pattern}, type={mapping.backend_type}')
print('OK: Models importable')
"
  </verify>
  <done>BackendMapping and CloudCredential models added to models.py</done>
</task>

<task type="auto">
  <name>Task 2: Ensure database creates new tables</name>
  <files>backend/mlx_manager/database.py</files>
  <action>
Verify that SQLModel's create_all will pick up the new tables. The existing database.py
uses SQLModel.metadata.create_all() which auto-discovers tables via table=True.

Check that the imports in database.py include the models module. If not, add:
```python
from mlx_manager import models  # noqa: F401 - Import for SQLModel table registration
```

This ensures BackendMapping and CloudCredential tables are registered with SQLModel metadata.
  </action>
  <verify>
cd /Users/atomasini/Development/mlx-manager/backend && python -c "
from sqlmodel import SQLModel
from mlx_manager.models import BackendMapping, CloudCredential
# Check tables are registered
tables = SQLModel.metadata.tables.keys()
print(f'Registered tables: {list(tables)}')
assert 'backend_mappings' in tables, 'backend_mappings table not registered'
assert 'cloud_credentials' in tables, 'cloud_credentials table not registered'
print('OK: Tables registered with SQLModel metadata')
"
  </verify>
  <done>New tables registered with SQLModel metadata</done>
</task>

<task type="auto">
  <name>Task 3: Add database model tests</name>
  <files>backend/tests/test_cloud_models.py</files>
  <action>
Create tests for the new database models:

1. Test BackendType enum:
   - All expected values exist (local, openai, anthropic)

2. Test BackendMapping model:
   - Create with required fields
   - Optional fields default correctly (enabled=True, priority=0)
   - Pattern matching examples (exact match, wildcard pattern)

3. Test CloudCredential model:
   - Create with required fields
   - backend_type is unique constraint
   - base_url is optional

4. Test schema validation:
   - BackendMappingCreate accepts valid data
   - CloudCredentialCreate accepts valid data
   - CloudCredentialResponse excludes API key
  </action>
  <verify>cd /Users/atomasini/Development/mlx-manager/backend && python -m pytest tests/test_cloud_models.py -v</verify>
  <done>Database model tests passing</done>
</task>

</tasks>

<verification>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
# Run model tests
python -m pytest tests/test_cloud_models.py -v

# Verify models are importable
python -c "from mlx_manager.models import BackendType, BackendMapping, CloudCredential; print('OK')"

# Type checking
mypy mlx_manager/models.py --ignore-missing-imports
```
</verification>

<success_criteria>
- BackendType enum has LOCAL, OPENAI, ANTHROPIC values
- BackendMapping table supports pattern-based routing with priority
- CloudCredential table stores encrypted API keys per backend
- Tables registered with SQLModel metadata for auto-creation
- All tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/10-dual-protocol-cloud-fallback/10-02-SUMMARY.md`
</output>
