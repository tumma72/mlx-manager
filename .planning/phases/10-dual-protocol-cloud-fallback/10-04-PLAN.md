---
phase: 10-dual-protocol-cloud-fallback
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/pyproject.toml
  - backend/mlx_manager/mlx_server/services/cloud/__init__.py
  - backend/mlx_manager/mlx_server/services/cloud/client.py
  - backend/tests/mlx_server/services/cloud/test_client.py
autonomous: true

must_haves:
  truths:
    - "httpx-retries installed and importable"
    - "pybreaker installed and importable"
    - "CloudBackendClient uses retry transport with exponential backoff"
    - "Circuit breaker prevents repeated calls to failing backend"
  artifacts:
    - path: "backend/mlx_manager/mlx_server/services/cloud/client.py"
      provides: "CloudBackendClient base class with retries"
      exports: ["CloudBackendClient"]
    - path: "backend/tests/mlx_server/services/cloud/test_client.py"
      provides: "Cloud client tests"
      min_lines: 50
  key_links:
    - from: "services/cloud/client.py"
      to: "httpx-retries"
      via: "import"
      pattern: "from httpx_retries import"
---

<objective>
Install cloud client dependencies and create base CloudBackendClient with retry and circuit breaker support.

Purpose: Enable resilient cloud API calls with automatic retry on transient failures and circuit breaker protection.
Output: CloudBackendClient base class that OpenAI and Anthropic backends will extend.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-dual-protocol-cloud-fallback/10-RESEARCH.md
@backend/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cloud client dependencies</name>
  <files>backend/pyproject.toml</files>
  <action>
Add the following dependencies to pyproject.toml under [project.dependencies]:

```toml
"httpx-retries>=0.4",
"pybreaker>=1.0",
```

Note: httpx is already a dependency (used by FastAPI and existing code).

After modifying pyproject.toml, run:
```bash
cd backend && uv sync
```

Verify installation:
```bash
python -c "from httpx_retries import Retry, RetryTransport; print('httpx-retries OK')"
python -c "import pybreaker; print('pybreaker OK')"
```
  </action>
  <verify>
cd /Users/atomasini/Development/mlx-manager/backend && python -c "
from httpx_retries import Retry, RetryTransport
import pybreaker
print('httpx-retries:', Retry.__module__)
print('pybreaker:', pybreaker.__version__)
print('OK: Dependencies installed')
"
  </verify>
  <done>httpx-retries and pybreaker installed</done>
</task>

<task type="auto">
  <name>Task 2: Create cloud client base class</name>
  <files>
backend/mlx_manager/mlx_server/services/cloud/__init__.py
backend/mlx_manager/mlx_server/services/cloud/client.py
  </files>
  <action>
Create the cloud services package:

1. __init__.py:
```python
"""Cloud backend services for fallback routing."""

from mlx_manager.mlx_server.services.cloud.client import CloudBackendClient

__all__ = ["CloudBackendClient"]
```

2. client.py - CloudBackendClient base class:
```python
"""Base cloud backend client with retry and circuit breaker support."""

import logging
from abc import ABC, abstractmethod
from collections.abc import AsyncGenerator
from typing import Any

import httpx
from httpx_retries import Retry, RetryTransport
from pybreaker import CircuitBreaker, CircuitBreakerError

logger = logging.getLogger(__name__)


class CloudBackendClient(ABC):
    """Base class for cloud backend clients with resilience patterns.

    Features:
    - Automatic retry with exponential backoff on transient failures
    - Circuit breaker to prevent cascade failures
    - Configurable timeouts
    """

    def __init__(
        self,
        base_url: str,
        api_key: str,
        max_retries: int = 3,
        backoff_factor: float = 0.5,
        timeout: float = 60.0,
        circuit_breaker_fail_max: int = 5,
        circuit_breaker_reset_timeout: int = 30,
    ):
        """Initialize cloud backend client.

        Args:
            base_url: API base URL
            api_key: API key for authentication
            max_retries: Maximum retry attempts (default: 3)
            backoff_factor: Exponential backoff factor (default: 0.5)
            timeout: Request timeout in seconds (default: 60)
            circuit_breaker_fail_max: Failures before circuit opens (default: 5)
            circuit_breaker_reset_timeout: Seconds before circuit resets (default: 30)
        """
        self.base_url = base_url
        self._api_key = api_key  # Keep private, don't log

        # Configure retry transport
        retry = Retry(
            total=max_retries,
            backoff_factor=backoff_factor,
            # Retry on these status codes
            status_forcelist=[429, 500, 502, 503, 504],
        )

        # Create async client with retry transport
        self._client = httpx.AsyncClient(
            base_url=base_url,
            transport=RetryTransport(retry=retry),
            timeout=httpx.Timeout(timeout, connect=10.0),
            headers=self._build_headers(),
        )

        # Circuit breaker per client instance
        self._circuit_breaker = CircuitBreaker(
            fail_max=circuit_breaker_fail_max,
            reset_timeout=circuit_breaker_reset_timeout,
        )

        logger.info(f"Initialized cloud client for {base_url}")

    @abstractmethod
    def _build_headers(self) -> dict[str, str]:
        """Build request headers. Subclasses implement auth-specific headers."""
        pass

    @abstractmethod
    async def chat_completion(
        self,
        messages: list[dict[str, Any]],
        model: str,
        max_tokens: int,
        temperature: float = 1.0,
        stream: bool = False,
        **kwargs: Any,
    ) -> AsyncGenerator[dict, None] | dict:
        """Send chat completion request. Subclasses implement API-specific format."""
        pass

    async def _post_with_circuit_breaker(
        self,
        endpoint: str,
        json_data: dict[str, Any],
    ) -> httpx.Response:
        """POST request with circuit breaker protection."""
        try:
            # Check circuit breaker state
            if self._circuit_breaker.current_state == "open":
                raise CircuitBreakerError("Circuit breaker is open")

            response = await self._client.post(endpoint, json=json_data)
            response.raise_for_status()

            # Success - record for circuit breaker
            self._circuit_breaker.success()
            return response

        except httpx.HTTPStatusError as e:
            self._circuit_breaker.failure()
            logger.warning(f"HTTP error from {self.base_url}: {e.response.status_code}")
            raise
        except Exception as e:
            self._circuit_breaker.failure()
            logger.warning(f"Request failed to {self.base_url}: {e}")
            raise

    async def _stream_with_circuit_breaker(
        self,
        endpoint: str,
        json_data: dict[str, Any],
    ) -> AsyncGenerator[str, None]:
        """Streaming POST with circuit breaker protection."""
        if self._circuit_breaker.current_state == "open":
            raise CircuitBreakerError("Circuit breaker is open")

        try:
            async with self._client.stream("POST", endpoint, json=json_data) as response:
                response.raise_for_status()
                async for line in response.aiter_lines():
                    yield line

            # Success after completing stream
            self._circuit_breaker.success()

        except Exception as e:
            self._circuit_breaker.failure()
            logger.warning(f"Stream failed to {self.base_url}: {e}")
            raise

    async def close(self) -> None:
        """Close the HTTP client."""
        await self._client.aclose()

    @property
    def is_circuit_open(self) -> bool:
        """Check if circuit breaker is open."""
        return self._circuit_breaker.current_state == "open"
```
  </action>
  <verify>
cd /Users/atomasini/Development/mlx-manager/backend && python -c "
from mlx_manager.mlx_server.services.cloud.client import CloudBackendClient
print(f'CloudBackendClient is abstract: {CloudBackendClient.__abstractmethods__}')
print('OK: CloudBackendClient importable')
"
  </verify>
  <done>CloudBackendClient base class created with retry and circuit breaker</done>
</task>

<task type="auto">
  <name>Task 3: Add cloud client tests</name>
  <files>backend/tests/mlx_server/services/cloud/test_client.py</files>
  <action>
Create tests for CloudBackendClient base class:

1. Create a concrete test implementation:
```python
class TestableCloudClient(CloudBackendClient):
    def _build_headers(self):
        return {"Authorization": f"Bearer {self._api_key}"}

    async def chat_completion(self, messages, model, max_tokens, temperature=1.0, stream=False, **kwargs):
        # Mock implementation for testing
        return {"choices": [{"message": {"content": "test"}}]}
```

2. Test initialization:
   - Client created with base_url and api_key
   - Circuit breaker initialized in closed state
   - Headers built correctly

3. Test circuit breaker:
   - Initially closed
   - Opens after fail_max failures
   - is_circuit_open property reflects state

4. Test _post_with_circuit_breaker:
   - Raises CircuitBreakerError when circuit is open
   - Records success on successful response
   - Records failure on HTTP error

5. Test close:
   - Client can be closed without error

Use httpx mocking (respx or unittest.mock) for HTTP calls.
  </action>
  <verify>cd /Users/atomasini/Development/mlx-manager/backend && python -m pytest tests/mlx_server/services/cloud/test_client.py -v</verify>
  <done>Cloud client tests passing</done>
</task>

</tasks>

<verification>
```bash
cd /Users/atomasini/Development/mlx-manager/backend

# Verify dependencies
python -c "from httpx_retries import Retry; import pybreaker; print('OK')"

# Run tests
python -m pytest tests/mlx_server/services/cloud/test_client.py -v

# Type checking
mypy mlx_manager/mlx_server/services/cloud/client.py
```
</verification>

<success_criteria>
- httpx-retries and pybreaker installed and importable
- CloudBackendClient uses retry transport with backoff
- Circuit breaker prevents repeated calls to failing backend
- is_circuit_open property works correctly
- All tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/10-dual-protocol-cloud-fallback/10-04-SUMMARY.md`
</output>
