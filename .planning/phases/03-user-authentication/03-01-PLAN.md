---
phase: 03-user-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/mlx_manager/models.py
  - backend/mlx_manager/config.py
  - backend/mlx_manager/services/auth_service.py
  - backend/mlx_manager/dependencies.py
  - backend/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Password can be hashed and verified correctly"
    - "JWT tokens can be created with user email and expiry"
    - "JWT tokens can be decoded and validated"
    - "User model exists with email, hashed_password, is_admin, status fields"
  artifacts:
    - path: "backend/mlx_manager/models.py"
      provides: "User, UserCreate, UserPublic, UserLogin, Token schemas"
      contains: "class User"
    - path: "backend/mlx_manager/services/auth_service.py"
      provides: "Password hashing and JWT functions"
      exports: ["hash_password", "verify_password", "create_access_token", "decode_token"]
    - path: "backend/mlx_manager/dependencies.py"
      provides: "Auth dependency injection functions"
      exports: ["get_current_user", "get_admin_user"]
    - path: "backend/mlx_manager/config.py"
      provides: "JWT settings"
      contains: "jwt_secret"
  key_links:
    - from: "backend/mlx_manager/services/auth_service.py"
      to: "backend/mlx_manager/config.py"
      via: "settings import for JWT secret"
      pattern: "from mlx_manager.config import settings"
---

<objective>
Create the backend authentication foundation: User database model, password hashing service, JWT token management, and auth dependency injection functions.

Purpose: Establish the core auth primitives that all other auth features will build upon.
Output: User model in database, auth_service.py with password/JWT functions, dependencies.py with auth guards.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-user-authentication/03-RESEARCH.md

@backend/mlx_manager/models.py
@backend/mlx_manager/config.py
@backend/mlx_manager/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth dependencies and User model</name>
  <files>
    backend/pyproject.toml
    backend/mlx_manager/models.py
    backend/mlx_manager/config.py
  </files>
  <action>
    1. Add dependencies to pyproject.toml:
       - pyjwt>=2.8.0
       - pwdlib[argon2]>=0.3.0

    2. Add JWT settings to config.py Settings class:
       - jwt_secret: str = Field(default="CHANGE_ME_IN_PRODUCTION")
       - jwt_algorithm: str = "HS256"
       - jwt_expire_days: int = 7

    3. Add User models to models.py (after existing models):
       - UserStatus enum: PENDING, APPROVED, DISABLED
       - UserBase(SQLModel): email field with unique=True, index=True
       - User(UserBase, table=True): id, hashed_password, is_admin (default False), status (default PENDING), created_at, approved_at (nullable), approved_by (nullable FK to users.id)
       - UserCreate(SQLModel): email, password (plain text input)
       - UserPublic(UserBase): id, is_admin, status, created_at (response model without password)
       - UserLogin(SQLModel): email, password
       - Token(SQLModel): access_token, token_type="bearer"
       - UserUpdate(SQLModel): email (optional), is_admin (optional), status (optional) - for admin updates

    Follow existing SQLModel patterns from ServerProfile models.
  </action>
  <verify>
    cd backend && source .venv/bin/activate
    ruff check mlx_manager/models.py mlx_manager/config.py
    mypy mlx_manager/models.py mlx_manager/config.py
  </verify>
  <done>User model with all required fields exists, JWT config settings defined, dependencies added</done>
</task>

<task type="auto">
  <name>Task 2: Create auth service with password hashing and JWT</name>
  <files>backend/mlx_manager/services/auth_service.py</files>
  <action>
    Create new file backend/mlx_manager/services/auth_service.py:

    1. Import pwdlib PasswordHash, jwt, datetime, timedelta, timezone
    2. Import settings from mlx_manager.config

    3. Create module-level password_hash instance:
       password_hash = PasswordHash.recommended()

    4. Implement hash_password(password: str) -> str:
       Return password_hash.hash(password)

    5. Implement verify_password(plain_password: str, hashed_password: str) -> bool:
       Return password_hash.verify(plain_password, hashed_password)

    6. Implement create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
       - Copy data dict
       - Calculate expire time (now + expires_delta or jwt_expire_days from settings)
       - Add "exp" claim
       - Return jwt.encode(to_encode, settings.jwt_secret, algorithm=settings.jwt_algorithm)

    7. Implement decode_token(token: str) -> dict | None:
       - Try jwt.decode with settings.jwt_secret and algorithm
       - Return payload on success, None on jwt.InvalidTokenError

    Use timezone-aware datetime (datetime.now(timezone.utc)) per research patterns.
  </action>
  <verify>
    cd backend && source .venv/bin/activate
    pip install -e ".[dev]"
    python -c "from mlx_manager.services.auth_service import hash_password, verify_password, create_access_token, decode_token; pw = hash_password('test'); print('Hash OK:', verify_password('test', pw)); token = create_access_token({'sub': 'test@test.com'}); print('Token OK:', decode_token(token) is not None)"
  </verify>
  <done>Auth service can hash passwords, verify them, create JWT tokens, and decode them</done>
</task>

<task type="auto">
  <name>Task 3: Create auth dependencies for route protection</name>
  <files>backend/mlx_manager/dependencies.py</files>
  <action>
    Create new file backend/mlx_manager/dependencies.py:

    1. Imports:
       - from typing import Annotated
       - from fastapi import Depends, HTTPException, status
       - from fastapi.security import OAuth2PasswordBearer
       - from sqlmodel import select
       - from sqlmodel.ext.asyncio.session import AsyncSession
       - from mlx_manager.database import get_db
       - from mlx_manager.models import User, UserStatus
       - from mlx_manager.services.auth_service import decode_token

    2. Create oauth2_scheme:
       oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")

    3. Implement get_current_user dependency:
       async def get_current_user(
           token: Annotated[str, Depends(oauth2_scheme)],
           session: AsyncSession = Depends(get_db)
       ) -> User:
       - Create credentials_exception with 401, "Could not validate credentials", WWW-Authenticate header
       - Decode token, raise if None or no "sub" claim
       - Query User by email (from "sub" claim)
       - Raise if user is None or user.status != UserStatus.APPROVED
       - Return user

    4. Implement get_admin_user dependency:
       async def get_admin_user(
           current_user: Annotated[User, Depends(get_current_user)]
       ) -> User:
       - Raise 403 "Admin access required" if not current_user.is_admin
       - Return current_user

    Follow the exact patterns from 03-RESEARCH.md Pattern 1.
  </action>
  <verify>
    cd backend && source .venv/bin/activate
    ruff check mlx_manager/dependencies.py
    mypy mlx_manager/dependencies.py
    python -c "from mlx_manager.dependencies import get_current_user, get_admin_user, oauth2_scheme; print('Dependencies imported OK')"
  </verify>
  <done>Auth dependencies exist and can be imported, ready to use in routers</done>
</task>

</tasks>

<verification>
All checks pass:
- ruff check passes for all modified files
- mypy passes for all modified files
- Auth service functions work correctly (hash, verify, token create/decode)
- Dependencies can be imported without errors
</verification>

<success_criteria>
1. User model added to models.py with all required fields
2. JWT settings added to config.py
3. auth_service.py exists with working password hashing and JWT functions
4. dependencies.py exists with get_current_user and get_admin_user
5. All lint and type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-authentication/03-01-SUMMARY.md`
</output>
