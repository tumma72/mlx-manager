---
phase: 03-user-authentication
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - backend/mlx_manager/routers/profiles.py
  - backend/mlx_manager/routers/models.py
  - backend/mlx_manager/routers/servers.py
  - backend/mlx_manager/routers/system.py
  - frontend/src/lib/stores/auth.svelte.ts
  - frontend/src/lib/stores/index.ts
  - frontend/src/lib/api/client.ts
  - frontend/src/lib/api/types.ts
autonomous: true

must_haves:
  truths:
    - "All existing API endpoints require authentication"
    - "API requests without valid token return 401"
    - "Frontend API client automatically includes auth header"
    - "Frontend auth store persists token and user in localStorage"
    - "401 responses clear auth state and redirect to login"
  artifacts:
    - path: "frontend/src/lib/stores/auth.svelte.ts"
      provides: "Auth state management"
      exports: ["authStore"]
    - path: "frontend/src/lib/api/client.ts"
      provides: "Auth header injection"
      contains: "Authorization"
  key_links:
    - from: "backend/mlx_manager/routers/profiles.py"
      to: "backend/mlx_manager/dependencies.py"
      via: "get_current_user dependency"
      pattern: "Depends\\(get_current_user\\)"
    - from: "frontend/src/lib/api/client.ts"
      to: "frontend/src/lib/stores/auth.svelte.ts"
      via: "authStore import for token"
      pattern: "import.*authStore"
---

<objective>
Secure the existing API endpoints with authentication and create the frontend auth infrastructure (store, API client auth headers).

Purpose: Wire up authentication so all API calls require valid JWT and frontend handles auth state.
Output: Protected backend routes, frontend auth store, auth-aware API client.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-user-authentication/03-RESEARCH.md

@backend/mlx_manager/routers/profiles.py
@backend/mlx_manager/routers/servers.py
@frontend/src/lib/api/client.ts
@frontend/src/lib/stores/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth dependencies to all existing backend routers</name>
  <files>
    backend/mlx_manager/routers/profiles.py
    backend/mlx_manager/routers/models.py
    backend/mlx_manager/routers/servers.py
    backend/mlx_manager/routers/system.py
  </files>
  <action>
    For each router file (profiles.py, models.py, servers.py, system.py):

    1. Add imports:
       - from typing import Annotated (if not present)
       - from mlx_manager.dependencies import get_current_user
       - from mlx_manager.models import User

    2. Add current_user parameter to EVERY endpoint function:
       current_user: Annotated[User, Depends(get_current_user)]

       This ensures all endpoints require authentication.

    Example transformation for profiles.py:
    ```python
    # Before
    @router.get("/profiles")
    async def list_profiles(session: AsyncSession = Depends(get_db)):

    # After
    @router.get("/profiles")
    async def list_profiles(
        current_user: Annotated[User, Depends(get_current_user)],
        session: AsyncSession = Depends(get_db)
    ):
    ```

    Apply this pattern to ALL endpoints in all four router files.
    The current_user parameter doesn't need to be used in the function body - the dependency injection handles auth validation.
  </action>
  <verify>
    cd backend && source .venv/bin/activate
    ruff check mlx_manager/routers/
    mypy mlx_manager/routers/
  </verify>
  <done>All existing API endpoints require authentication via get_current_user dependency</done>
</task>

<task type="auto">
  <name>Task 2: Create frontend auth store and types</name>
  <files>
    frontend/src/lib/api/types.ts
    frontend/src/lib/stores/auth.svelte.ts
    frontend/src/lib/stores/index.ts
  </files>
  <action>
    1. Add auth types to frontend/src/lib/api/types.ts:
       ```typescript
       export type UserStatus = "pending" | "approved" | "disabled";

       export interface User {
         id: number;
         email: string;
         is_admin: boolean;
         status: UserStatus;
         created_at: string;
       }

       export interface Token {
         access_token: string;
         token_type: string;
       }

       export interface UserCreate {
         email: string;
         password: string;
       }

       export interface PasswordReset {
         password: string;
       }

       export interface UserUpdate {
         email?: string;
         is_admin?: boolean;
         status?: UserStatus;
       }
       ```

    2. Create frontend/src/lib/stores/auth.svelte.ts:
       - Use Svelte 5 runes ($state) following existing store patterns
       - Constants: TOKEN_KEY = 'mlx_auth_token', USER_KEY = 'mlx_auth_user'
       - State: token, user, loading (initialized from localStorage on client)
       - Derived: isAuthenticated (!!token && !!user), isAdmin (user?.is_admin ?? false)
       - Methods:
         - setAuth(token: string, user: User): save to state and localStorage
         - clearAuth(): clear state and localStorage
         - initialize(): load from localStorage, set loading=false
       - Export authStore singleton

       Follow the pattern from 03-RESEARCH.md Pattern 3, adapted for existing store style.

    3. Update frontend/src/lib/stores/index.ts:
       - Add: export { authStore } from "./auth.svelte";
  </action>
  <verify>
    cd frontend && npm run check
  </verify>
  <done>Auth store exists with token/user state, localStorage persistence, and exports</done>
</task>

<task type="auto">
  <name>Task 3: Add auth headers to API client and handle 401s</name>
  <files>frontend/src/lib/api/client.ts</files>
  <action>
    Update frontend/src/lib/api/client.ts:

    1. Import authStore:
       import { authStore } from "$lib/stores";

    2. Create getAuthHeaders helper function:
       ```typescript
       function getAuthHeaders(): HeadersInit {
         const headers: HeadersInit = { "Content-Type": "application/json" };
         if (authStore.token) {
           headers["Authorization"] = `Bearer ${authStore.token}`;
         }
         return headers;
       }
       ```

    3. Update handleResponse to handle 401:
       ```typescript
       async function handleResponse<T>(response: Response): Promise<T> {
         if (response.status === 401) {
           // Token expired or invalid - clear auth and redirect
           authStore.clearAuth();
           if (typeof window !== "undefined") {
             window.location.href = "/login";
           }
           throw new ApiError(401, "Session expired");
         }
         // ... rest of existing error handling
       }
       ```

    4. Update all fetch calls to use getAuthHeaders():
       - profiles.list, get, create, update, delete, duplicate, getNextPort
       - models.search, listLocal, startDownload, getActiveDownloads, delete, detectOptions, getAvailableParsers
       - servers.list, start, stop, restart, health, status
       - system.memory, info, parserOptions, launchd.install, launchd.uninstall, launchd.status

       For GET requests without body:
       ```typescript
       const res = await fetch(`${API_BASE}/profiles`, {
         headers: getAuthHeaders()
       });
       ```

       For POST/PUT with body:
       ```typescript
       const res = await fetch(`${API_BASE}/profiles`, {
         method: "POST",
         headers: getAuthHeaders(),
         body: JSON.stringify(data),
       });
       ```

    5. Add auth API namespace (before export { ApiError }):
       ```typescript
       export const auth = {
         register: async (data: { email: string; password: string }): Promise<User> => {
           const res = await fetch(`${API_BASE}/auth/register`, {
             method: "POST",
             headers: { "Content-Type": "application/json" },
             body: JSON.stringify(data),
           });
           return handleResponse(res);
         },

         login: async (email: string, password: string): Promise<Token> => {
           const formData = new URLSearchParams();
           formData.append("username", email);  // OAuth2 form uses "username"
           formData.append("password", password);

           const res = await fetch(`${API_BASE}/auth/login`, {
             method: "POST",
             headers: { "Content-Type": "application/x-www-form-urlencoded" },
             body: formData,
           });
           return handleResponse(res);
         },

         me: async (): Promise<User> => {
           const res = await fetch(`${API_BASE}/auth/me`, {
             headers: getAuthHeaders(),
           });
           return handleResponse(res);
         },

         listUsers: async (): Promise<User[]> => {
           const res = await fetch(`${API_BASE}/auth/users`, {
             headers: getAuthHeaders(),
           });
           return handleResponse(res);
         },

         getPendingCount: async (): Promise<{ count: number }> => {
           const res = await fetch(`${API_BASE}/auth/users/pending/count`, {
             headers: getAuthHeaders(),
           });
           return handleResponse(res);
         },

         updateUser: async (userId: number, data: UserUpdate): Promise<User> => {
           const res = await fetch(`${API_BASE}/auth/users/${userId}`, {
             method: "PUT",
             headers: getAuthHeaders(),
             body: JSON.stringify(data),
           });
           return handleResponse(res);
         },

         deleteUser: async (userId: number): Promise<void> => {
           const res = await fetch(`${API_BASE}/auth/users/${userId}`, {
             method: "DELETE",
             headers: getAuthHeaders(),
           });
           return handleResponse(res);
         },

         resetPassword: async (userId: number, password: string): Promise<{ message: string }> => {
           const res = await fetch(`${API_BASE}/auth/users/${userId}/reset-password`, {
             method: "POST",
             headers: getAuthHeaders(),
             body: JSON.stringify({ password }),
           });
           return handleResponse(res);
         },
       };
       ```

    Import User, Token, UserUpdate from types.ts at the top.
  </action>
  <verify>
    cd frontend && npm run check && npm run lint
  </verify>
  <done>API client adds auth headers to all requests, handles 401s, and has auth API namespace</done>
</task>

</tasks>

<verification>
All checks pass:
- Backend: ruff check and mypy pass for all routers
- Frontend: npm run check and npm run lint pass
- All API endpoints now require authentication
- Frontend auth store and API client are properly integrated
</verification>

<success_criteria>
1. All backend routers require get_current_user dependency
2. Frontend auth store exists with token/user persistence
3. API client includes Authorization header on all requests
4. 401 responses clear auth and redirect to /login
5. Auth API namespace provides all authentication endpoints
6. All lint and type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-authentication/03-03-SUMMARY.md`
</output>
