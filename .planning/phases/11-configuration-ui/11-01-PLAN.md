---
phase: 11-configuration-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/mlx_manager/services/encryption_service.py
  - backend/mlx_manager/routers/settings.py
  - backend/mlx_manager/main.py
  - backend/mlx_manager/models.py
  - backend/tests/test_encryption_service.py
  - backend/tests/test_settings_router.py
autonomous: true

must_haves:
  truths:
    - "API keys are encrypted before storage"
    - "Encrypted keys can be decrypted for use"
    - "Settings API returns credentials without exposing keys"
    - "Connection test validates API key with provider"
  artifacts:
    - path: "backend/mlx_manager/services/encryption_service.py"
      provides: "Fernet-based encryption for API keys"
      exports: ["encrypt_api_key", "decrypt_api_key"]
    - path: "backend/mlx_manager/routers/settings.py"
      provides: "Settings CRUD endpoints"
      exports: ["router"]
    - path: "backend/tests/test_encryption_service.py"
      provides: "Encryption service tests"
      min_lines: 50
    - path: "backend/tests/test_settings_router.py"
      provides: "Settings API tests"
      min_lines: 150
  key_links:
    - from: "backend/mlx_manager/routers/settings.py"
      to: "backend/mlx_manager/services/encryption_service.py"
      via: "encrypt_api_key/decrypt_api_key calls"
      pattern: "encrypt_api_key|decrypt_api_key"
    - from: "backend/mlx_manager/main.py"
      to: "backend/mlx_manager/routers/settings.py"
      via: "router include"
      pattern: "settings\\.router"
---

<objective>
Create backend encryption service and settings API endpoints for cloud provider credentials, routing rules, and model pool configuration.

Purpose: Enable secure storage and retrieval of API keys (encrypted at rest) and provide CRUD endpoints for all configuration data that the frontend settings UI will consume.

Output: Encryption service module, settings router with full CRUD for providers/rules/pool config, comprehensive tests.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-configuration-ui/11-CONTEXT.md
@.planning/phases/11-configuration-ui/11-RESEARCH.md
@backend/mlx_manager/config.py
@backend/mlx_manager/models.py
@backend/mlx_manager/database.py
@backend/mlx_manager/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create encryption service for API keys</name>
  <files>
    backend/mlx_manager/services/encryption_service.py
    backend/tests/test_encryption_service.py
  </files>
  <action>
Create Fernet-based encryption service for API keys:

1. Create `backend/mlx_manager/services/encryption_service.py`:
   - Import from `cryptography.fernet`, `cryptography.hazmat.primitives.kdf.pbkdf2`
   - Salt file path: `settings.database_path.parent / ".encryption_salt"`
   - `_get_or_create_salt()`: Read salt file if exists, else create 16-byte random salt and persist
   - `_get_fernet()`: Derive 32-byte key from `settings.jwt_secret` + salt using PBKDF2HMAC (SHA256, 1_200_000 iterations), return Fernet instance
   - `encrypt_api_key(plain_key: str) -> str`: Encrypt and return base64-encoded string
   - `decrypt_api_key(encrypted_key: str) -> str`: Decrypt and return plain string
   - Cache the Fernet instance at module level to avoid repeated derivation

2. Create `backend/tests/test_encryption_service.py`:
   - Test encrypt/decrypt roundtrip
   - Test different keys produce different ciphertext
   - Test decryption with wrong key fails (InvalidToken)
   - Test salt persistence (same salt across calls)
   - Use tmp_path fixture for isolated salt file
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
source .venv/bin/activate
pytest tests/test_encryption_service.py -v
```
  </verify>
  <done>
Encryption service exists with encrypt/decrypt functions, all tests pass, salt file persists correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add model pool configuration model</name>
  <files>
    backend/mlx_manager/models.py
  </files>
  <action>
Add ServerConfig model and schemas to models.py for storing global server configuration:

1. Add `ServerConfig` SQLModel table:
   ```python
   class ServerConfig(SQLModel, table=True):
       """Global server configuration (singleton - only id=1 used)."""
       __tablename__ = "server_config"

       id: int | None = Field(default=None, primary_key=True)
       # Model pool settings
       memory_limit_mode: str = Field(default="percent")  # "percent" or "gb"
       memory_limit_value: int = Field(default=80)  # % or GB depending on mode
       eviction_policy: str = Field(default="lru")  # "lru", "lfu", "ttl"
       preload_models: str = Field(default="[]")  # JSON array of model paths
       updated_at: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))
   ```

2. Add `ServerConfigUpdate` schema:
   ```python
   class ServerConfigUpdate(SQLModel):
       memory_limit_mode: str | None = None
       memory_limit_value: int | None = None
       eviction_policy: str | None = None
       preload_models: list[str] | None = None
   ```

3. Add `ServerConfigResponse` schema:
   ```python
   class ServerConfigResponse(SQLModel):
       memory_limit_mode: str
       memory_limit_value: int
       eviction_policy: str
       preload_models: list[str]  # Parsed from JSON
   ```

4. Add `pattern_type` field to `BackendMapping` model:
   ```python
   pattern_type: str = Field(default="exact")  # "exact", "prefix", "regex"
   ```
   Also add to `BackendMappingCreate` and `BackendMappingResponse` schemas.
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
source .venv/bin/activate
python -c "from mlx_manager.models import ServerConfig, ServerConfigUpdate, ServerConfigResponse, BackendMapping; print('Models OK')"
```
  </verify>
  <done>
ServerConfig table and schemas exist, BackendMapping has pattern_type field.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create settings router with full CRUD</name>
  <files>
    backend/mlx_manager/routers/settings.py
    backend/mlx_manager/main.py
    backend/tests/test_settings_router.py
  </files>
  <action>
Create settings router with endpoints for providers, routing rules, and model pool config:

1. Create `backend/mlx_manager/routers/settings.py`:

**Provider endpoints:**
- `GET /api/settings/providers` - List all configured providers (returns CloudCredentialResponse[], no API keys)
- `POST /api/settings/providers` - Create/update provider (upsert by backend_type), encrypt API key before storage
- `DELETE /api/settings/providers/{backend_type}` - Delete provider credentials
- `POST /api/settings/providers/{backend_type}/test` - Test connection:
  - For OpenAI: GET `{base_url}/v1/models` with Bearer token
  - For Anthropic: GET `{base_url}/v1/models` with `x-api-key` header
  - Return `{"success": true}` or raise HTTPException with error details

**Routing rules endpoints:**
- `GET /api/settings/rules` - List all rules ordered by priority DESC
- `POST /api/settings/rules` - Create new rule
- `PUT /api/settings/rules/{id}` - Update rule
- `DELETE /api/settings/rules/{id}` - Delete rule
- `PUT /api/settings/rules/priorities` - Batch update priorities (for drag-drop reorder)
  - Body: `[{"id": 1, "priority": 100}, {"id": 2, "priority": 90}]`
- `POST /api/settings/rules/test` - Test which rule matches a model name
  - Body: `{"model_name": "gpt-4"}`
  - Response: `{"matched_rule_id": 1, "backend_type": "openai"}` or `{"matched_rule_id": null, "backend_type": "local"}`

**Model pool config endpoints:**
- `GET /api/settings/pool` - Get current pool config (creates default if not exists)
- `PUT /api/settings/pool` - Update pool config

2. Update `backend/mlx_manager/main.py`:
   - Import settings router: `from mlx_manager.routers import settings`
   - Include router: `app.include_router(settings.router)`

3. Create `backend/tests/test_settings_router.py`:
   - Test all provider CRUD operations
   - Test API key is not returned in responses
   - Test connection test endpoint (mock httpx)
   - Test all rule CRUD operations
   - Test priority batch update
   - Test rule matching with different pattern types (exact, prefix, regex)
   - Test pool config get/update
   - Test upsert behavior (update existing provider vs create new)
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/backend
source .venv/bin/activate
pytest tests/test_settings_router.py -v
ruff check mlx_manager/routers/settings.py
mypy mlx_manager/routers/settings.py
```
  </verify>
  <done>
Settings router registered in main.py, all CRUD endpoints work, tests pass, linting clean.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd /Users/atomasini/Development/mlx-manager/backend
source .venv/bin/activate

# Run all new tests
pytest tests/test_encryption_service.py tests/test_settings_router.py -v

# Quality checks
ruff check mlx_manager/services/encryption_service.py mlx_manager/routers/settings.py
mypy mlx_manager/services/encryption_service.py mlx_manager/routers/settings.py

# Integration test - start server and test endpoints
uvicorn mlx_manager.main:app --port 8080 &
sleep 2
curl -X POST http://localhost:8080/api/settings/providers \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"backend_type": "openai", "api_key": "sk-test123"}'
kill %1
```
</verification>

<success_criteria>
- [ ] Encryption service encrypts/decrypts API keys correctly
- [ ] Salt file persists in ~/.mlx-manager/
- [ ] Settings router provides full CRUD for providers, rules, pool config
- [ ] API keys never returned in responses
- [ ] Connection test validates with real provider APIs (mocked in tests)
- [ ] Rule matching supports exact, prefix, and regex patterns
- [ ] All tests pass, linting clean
</success_criteria>

<output>
After completion, create `.planning/phases/11-configuration-ui/11-01-SUMMARY.md`
</output>
