---
phase: 11-configuration-ui
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - frontend/src/routes/(protected)/settings/+page.svelte
  - frontend/src/lib/components/settings/ProviderSection.svelte
  - frontend/src/lib/components/settings/ProviderForm.svelte
  - frontend/src/lib/components/settings/index.ts
  - frontend/src/lib/api/types.ts
  - frontend/src/lib/api/client.ts
autonomous: true

must_haves:
  truths:
    - "User can navigate to /settings page"
    - "User can expand/collapse provider sections"
    - "User can enter API key and see masked display"
    - "User can test connection and see success/error status"
    - "Status dot shows green/red/gray based on connection status"
  artifacts:
    - path: "frontend/src/routes/(protected)/settings/+page.svelte"
      provides: "Main settings page with providers section"
      min_lines: 30
    - path: "frontend/src/lib/components/settings/ProviderSection.svelte"
      provides: "Accordion sections for providers with status dots"
      min_lines: 60
    - path: "frontend/src/lib/components/settings/ProviderForm.svelte"
      provides: "API key input with masking and connection test"
      min_lines: 80
  key_links:
    - from: "frontend/src/lib/components/settings/ProviderForm.svelte"
      to: "/api/settings/providers"
      via: "fetch calls"
      pattern: "settings\\.createProvider|settings\\.testProvider"
    - from: "frontend/src/routes/(protected)/settings/+page.svelte"
      to: "frontend/src/lib/components/settings/ProviderSection.svelte"
      via: "component import"
      pattern: "ProviderSection"
---

<objective>
Create the settings page and cloud provider configuration UI with accordion sections, masked API key inputs, and connection testing.

Purpose: Enable users to configure OpenAI and Anthropic API keys through an intuitive accordion-based interface with real-time connection validation.

Output: Settings route page, ProviderSection and ProviderForm components, API client extensions.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-configuration-ui/11-CONTEXT.md
@.planning/phases/11-configuration-ui/11-RESEARCH.md
@frontend/src/lib/api/client.ts
@frontend/src/lib/api/types.ts
@frontend/src/lib/components/ui/card.svelte
@frontend/src/lib/components/ui/input.svelte
@frontend/src/lib/components/ui/button.svelte
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add settings API types and client</name>
  <files>
    frontend/src/lib/api/types.ts
    frontend/src/lib/api/client.ts
  </files>
  <action>
Extend the API client with settings endpoints:

1. Add types to `frontend/src/lib/api/types.ts`:
   ```typescript
   // Backend types
   export type BackendType = "local" | "openai" | "anthropic";
   export type PatternType = "exact" | "prefix" | "regex";
   export type EvictionPolicy = "lru" | "lfu" | "ttl";
   export type MemoryLimitMode = "percent" | "gb";

   // Cloud provider credentials
   export interface CloudCredential {
     id: number;
     backend_type: BackendType;
     base_url: string | null;
     created_at: string;
   }

   export interface CloudCredentialCreate {
     backend_type: BackendType;
     api_key: string;
     base_url?: string;
   }

   // Backend routing rules
   export interface BackendMapping {
     id: number;
     model_pattern: string;
     pattern_type: PatternType;
     backend_type: BackendType;
     backend_model: string | null;
     fallback_backend: BackendType | null;
     priority: number;
     enabled: boolean;
   }

   export interface BackendMappingCreate {
     model_pattern: string;
     pattern_type?: PatternType;
     backend_type: BackendType;
     backend_model?: string;
     fallback_backend?: BackendType;
     priority?: number;
   }

   // Server pool configuration
   export interface ServerPoolConfig {
     memory_limit_mode: MemoryLimitMode;
     memory_limit_value: number;
     eviction_policy: EvictionPolicy;
     preload_models: string[];
   }

   export interface ServerPoolConfigUpdate {
     memory_limit_mode?: MemoryLimitMode;
     memory_limit_value?: number;
     eviction_policy?: EvictionPolicy;
     preload_models?: string[];
   }

   // Rule test result
   export interface RuleTestResult {
     matched_rule_id: number | null;
     backend_type: BackendType;
   }
   ```

2. Add settings API to `frontend/src/lib/api/client.ts`:
   ```typescript
   import type {
     // ... existing imports
     CloudCredential,
     CloudCredentialCreate,
     BackendMapping,
     BackendMappingCreate,
     ServerPoolConfig,
     ServerPoolConfigUpdate,
     RuleTestResult,
     BackendType,
   } from "./types";

   // Settings API
   export const settings = {
     // Providers
     listProviders: async (): Promise<CloudCredential[]> => {
       const res = await fetch(`${API_BASE}/settings/providers`, {
         headers: getAuthHeaders(),
       });
       return handleResponse(res);
     },

     createProvider: async (data: CloudCredentialCreate): Promise<CloudCredential> => {
       const res = await fetch(`${API_BASE}/settings/providers`, {
         method: "POST",
         headers: getAuthHeaders(),
         body: JSON.stringify(data),
       });
       return handleResponse(res);
     },

     deleteProvider: async (backendType: BackendType): Promise<void> => {
       const res = await fetch(`${API_BASE}/settings/providers/${backendType}`, {
         method: "DELETE",
         headers: getAuthHeaders(),
       });
       return handleResponse(res);
     },

     testProvider: async (backendType: BackendType): Promise<{ success: boolean }> => {
       const res = await fetch(`${API_BASE}/settings/providers/${backendType}/test`, {
         method: "POST",
         headers: getAuthHeaders(),
       });
       return handleResponse(res);
     },

     // Rules
     listRules: async (): Promise<BackendMapping[]> => {
       const res = await fetch(`${API_BASE}/settings/rules`, {
         headers: getAuthHeaders(),
       });
       return handleResponse(res);
     },

     createRule: async (data: BackendMappingCreate): Promise<BackendMapping> => {
       const res = await fetch(`${API_BASE}/settings/rules`, {
         method: "POST",
         headers: getAuthHeaders(),
         body: JSON.stringify(data),
       });
       return handleResponse(res);
     },

     updateRule: async (id: number, data: Partial<BackendMappingCreate>): Promise<BackendMapping> => {
       const res = await fetch(`${API_BASE}/settings/rules/${id}`, {
         method: "PUT",
         headers: getAuthHeaders(),
         body: JSON.stringify(data),
       });
       return handleResponse(res);
     },

     deleteRule: async (id: number): Promise<void> => {
       const res = await fetch(`${API_BASE}/settings/rules/${id}`, {
         method: "DELETE",
         headers: getAuthHeaders(),
       });
       return handleResponse(res);
     },

     updateRulePriorities: async (priorities: { id: number; priority: number }[]): Promise<void> => {
       const res = await fetch(`${API_BASE}/settings/rules/priorities`, {
         method: "PUT",
         headers: getAuthHeaders(),
         body: JSON.stringify(priorities),
       });
       return handleResponse(res);
     },

     testRule: async (modelName: string): Promise<RuleTestResult> => {
       const res = await fetch(`${API_BASE}/settings/rules/test`, {
         method: "POST",
         headers: getAuthHeaders(),
         body: JSON.stringify({ model_name: modelName }),
       });
       return handleResponse(res);
     },

     // Pool config
     getPoolConfig: async (): Promise<ServerPoolConfig> => {
       const res = await fetch(`${API_BASE}/settings/pool`, {
         headers: getAuthHeaders(),
       });
       return handleResponse(res);
     },

     updatePoolConfig: async (data: ServerPoolConfigUpdate): Promise<ServerPoolConfig> => {
       const res = await fetch(`${API_BASE}/settings/pool`, {
         method: "PUT",
         headers: getAuthHeaders(),
         body: JSON.stringify(data),
       });
       return handleResponse(res);
     },
   };
   ```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/frontend
npm run check
```
  </verify>
  <done>
Settings API types defined, client methods implemented, TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProviderForm component</name>
  <files>
    frontend/src/lib/components/settings/ProviderForm.svelte
  </files>
  <action>
Create the API key input form with masking and connection testing:

1. Create `frontend/src/lib/components/settings/ProviderForm.svelte`:
   - Props: `backendType: BackendType`, `existingCredential: CloudCredential | null`, `onSave: () => void`
   - State:
     - `apiKey: string` - The current input value
     - `baseUrl: string` - Custom base URL (optional)
     - `showAdvanced: boolean` - Toggle for base URL field
     - `testing: boolean` - Loading state for connection test
     - `saving: boolean` - Loading state for save
     - `testResult: 'success' | 'error' | null` - Connection test result
     - `error: string | null` - Error message
   - Masking function: Show `****...${last4chars}` while typing
   - **Save and test workflow (two sequential API calls):**
     1. Call `settings.createProvider({ backend_type, api_key, base_url })` to save/update credentials
     2. On success, immediately call `settings.testProvider(backend_type)` to validate with the provider
     3. Update testResult based on test response
     4. Call `onSave()` to refresh parent
   - Manual test button: Call `settings.testProvider(backend_type)` to re-test saved credentials
   - Clear testResult when apiKey changes (prevent stale results)
   - Show inline error below API key input field
   - Use existing ui components: Input, Button from `$components/ui`
   - Style: Form layout with label, masked input, save/test buttons

**Important workflow clarification:** The test endpoint (`POST /api/settings/providers/{backend_type}/test`) tests already-saved credentials from the database. Therefore the save-then-test flow is:
1. Save credentials via createProvider (persists encrypted key to DB)
2. Test the saved credentials via testProvider (reads from DB and validates with provider)

This is intentional - we only test persisted credentials, not unsaved input.

Example structure:
```svelte
<script lang="ts">
  import { settings } from '$lib/api/client';
  import type { BackendType, CloudCredential } from '$lib/api/types';
  import { Button } from '$components/ui';
  import { Check, X, Loader2, RefreshCw } from 'lucide-svelte';

  interface Props {
    backendType: BackendType;
    existingCredential: CloudCredential | null;
    onSave: () => void;
  }

  let { backendType, existingCredential, onSave }: Props = $props();

  let apiKey = $state('');
  let baseUrl = $state(existingCredential?.base_url ?? '');
  let showAdvanced = $state(!!existingCredential?.base_url);
  let testing = $state(false);
  let saving = $state(false);
  let testResult = $state<'success' | 'error' | null>(null);
  let error = $state<string | null>(null);

  const maskedKey = $derived(
    apiKey.length > 4 ? `****...${apiKey.slice(-4)}` : apiKey ? '****' : ''
  );

  // Clear test result when key changes
  $effect(() => {
    if (apiKey) testResult = null;
  });

  async function handleSave() {
    saving = true;
    error = null;
    try {
      // Step 1: Save credentials to database
      await settings.createProvider({
        backend_type: backendType,
        api_key: apiKey,
        base_url: baseUrl || undefined,
      });

      // Step 2: Test the saved credentials
      try {
        await settings.testProvider(backendType);
        testResult = 'success';
      } catch {
        testResult = 'error';
        // Still call onSave since credentials were saved
      }

      onSave();
      apiKey = ''; // Clear input after successful save
    } catch (e) {
      error = e instanceof Error ? e.message : 'Failed to save';
    } finally {
      saving = false;
    }
  }

  async function handleTest() {
    // Test already-saved credentials
    if (!existingCredential) return;
    testing = true;
    error = null;
    try {
      await settings.testProvider(backendType);
      testResult = 'success';
    } catch (e) {
      testResult = 'error';
      error = e instanceof Error ? e.message : 'Connection test failed';
    } finally {
      testing = false;
    }
  }
</script>
```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/frontend
npm run check
```
  </verify>
  <done>
ProviderForm component renders API key input with masking, save button persists then tests, manual test button re-tests saved credentials, inline errors display, TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ProviderSection and settings page</name>
  <files>
    frontend/src/lib/components/settings/ProviderSection.svelte
    frontend/src/lib/components/settings/index.ts
    frontend/src/routes/(protected)/settings/+page.svelte
  </files>
  <action>
Create the provider accordion section and main settings page:

1. Create `frontend/src/lib/components/settings/ProviderSection.svelte`:
   - Uses bits-ui Accordion (already installed)
   - Shows OpenAI and Anthropic as expandable sections
   - Each section header shows:
     - Status dot: green (connected), red (error), gray (not configured)
     - Provider name
     - ChevronDown icon that rotates when open
   - Content: ProviderForm component
   - Fetch providers on mount and after each save

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { Accordion } from 'bits-ui';
  import { ChevronDown } from 'lucide-svelte';
  import { settings } from '$lib/api/client';
  import type { CloudCredential, BackendType } from '$lib/api/types';
  import ProviderForm from './ProviderForm.svelte';

  const PROVIDERS: { type: BackendType; label: string }[] = [
    { type: 'openai', label: 'OpenAI' },
    { type: 'anthropic', label: 'Anthropic' },
  ];

  let credentials = $state<CloudCredential[]>([]);
  let connectionStatus = $state<Record<BackendType, 'connected' | 'error' | 'unconfigured'>>({
    local: 'connected', // Always "connected" for local
    openai: 'unconfigured',
    anthropic: 'unconfigured',
  });

  async function loadProviders() {
    credentials = await settings.listProviders();
    // Test connection for each configured provider
    for (const cred of credentials) {
      try {
        await settings.testProvider(cred.backend_type);
        connectionStatus[cred.backend_type] = 'connected';
      } catch {
        connectionStatus[cred.backend_type] = 'error';
      }
    }
  }

  onMount(loadProviders);

  function getCredential(type: BackendType): CloudCredential | null {
    return credentials.find(c => c.backend_type === type) ?? null;
  }
</script>
```

2. Create `frontend/src/lib/components/settings/index.ts`:
   ```typescript
   export { default as ProviderSection } from './ProviderSection.svelte';
   export { default as ProviderForm } from './ProviderForm.svelte';
   ```

3. Create `frontend/src/routes/(protected)/settings/+page.svelte`:
   - Import ProviderSection
   - Page title "Settings"
   - Section heading "Cloud Providers"
   - ProviderSection component
   - Placeholder sections for "Model Pool" and "Routing Rules" (implemented in subsequent plans)

```svelte
<script lang="ts">
  import { ProviderSection } from '$lib/components/settings';
</script>

<div class="space-y-8">
  <h1 class="text-2xl font-bold text-gray-900 dark:text-gray-100">Settings</h1>

  <!-- Cloud Providers -->
  <section>
    <h2 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">Cloud Providers</h2>
    <p class="text-sm text-muted-foreground mb-4">
      Configure API keys for cloud inference providers. Keys are encrypted at rest.
    </p>
    <ProviderSection />
  </section>

  <!-- Model Pool (placeholder) -->
  <section>
    <h2 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">Model Pool</h2>
    <p class="text-sm text-muted-foreground">Coming soon...</p>
  </section>

  <!-- Routing Rules (placeholder) -->
  <section>
    <h2 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">Model Routing Rules</h2>
    <p class="text-sm text-muted-foreground">Coming soon...</p>
  </section>
</div>
```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/frontend
npm run check
npm run lint
```
  </verify>
  <done>
ProviderSection renders accordion with status dots, ProviderForm embedded in each section, settings page exists at /settings, TypeScript and ESLint pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd /Users/atomasini/Development/mlx-manager/frontend

# Type checking
npm run check

# Linting
npm run lint

# Verify page exists
ls -la src/routes/\(protected\)/settings/

# Verify components exist
ls -la src/lib/components/settings/
```

Manual verification:
1. Start dev servers: `./scripts/dev.sh`
2. Navigate to http://localhost:5173/settings
3. Verify provider accordion renders with OpenAI and Anthropic sections
4. Expand a section and verify API key input appears
5. Enter a test key and verify masked display shows `****...xxxx`
6. Click Save - verify credentials persist AND connection test runs automatically
7. Click Test button - verify it tests the saved credentials (not the input field)
</verification>

<success_criteria>
- [ ] Settings page accessible at /settings
- [ ] Provider accordion shows OpenAI and Anthropic sections
- [ ] Status dots display correctly (gray when unconfigured)
- [ ] API key input masks value as `****...last4`
- [ ] Save button stores encrypted key then auto-tests the saved credentials
- [ ] Test button validates saved credentials with provider API
- [ ] Inline error displays below input on failure
- [ ] All TypeScript compiles, ESLint passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-configuration-ui/11-02-SUMMARY.md`
</output>
