---
phase: 11-configuration-ui
plan: 04
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - frontend/src/lib/components/settings/RoutingRulesSection.svelte
  - frontend/src/lib/components/settings/RuleCard.svelte
  - frontend/src/lib/components/settings/RuleForm.svelte
  - frontend/src/lib/components/settings/RuleTestInput.svelte
  - frontend/src/lib/components/settings/index.ts
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "User can view all routing rules as cards"
    - "User can drag-drop cards to reorder priority"
    - "User can create new rules with pattern, type, and backend"
    - "User can delete existing rules"
    - "User can test which rule matches a model name"
    - "Rules with unconfigured providers show warning badge"
  artifacts:
    - path: "frontend/src/lib/components/settings/RoutingRulesSection.svelte"
      provides: "Drag-drop sortable list of rule cards"
      min_lines: 80
    - path: "frontend/src/lib/components/settings/RuleCard.svelte"
      provides: "Individual rule card with pattern, backend, actions"
      min_lines: 60
    - path: "frontend/src/lib/components/settings/RuleForm.svelte"
      provides: "Form for creating/editing rules"
      min_lines: 80
    - path: "frontend/src/lib/components/settings/RuleTestInput.svelte"
      provides: "Test input showing which rule matches"
      min_lines: 40
  key_links:
    - from: "frontend/src/lib/components/settings/RoutingRulesSection.svelte"
      to: "/api/settings/rules"
      via: "fetch calls"
      pattern: "settings\\.listRules|settings\\.updateRulePriorities"
    - from: "frontend/src/lib/components/settings/RuleForm.svelte"
      to: "/api/settings/rules"
      via: "settings.createRule"
      pattern: "settings\\.createRule"
---

<objective>
Create the model routing rules UI with drag-drop reordering, rule cards, creation form, and test functionality.

Purpose: Enable users to define, prioritize, and test model-to-backend routing rules through a visual card-based interface with drag-drop priority management.

Output: RoutingRulesSection, RuleCard, RuleForm, RuleTestInput components.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-configuration-ui/11-CONTEXT.md
@.planning/phases/11-configuration-ui/11-RESEARCH.md
@frontend/src/lib/api/client.ts
@frontend/src/lib/api/types.ts
@frontend/src/lib/components/ui/badge.svelte
@frontend/src/lib/components/ui/card.svelte
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install drag-drop library and create RuleCard</name>
  <files>
    frontend/package.json
    frontend/src/lib/components/settings/RuleCard.svelte
  </files>
  <action>
Install the Svelte 5 compatible drag-drop library and create the rule card component:

1. Install dependency:
   ```bash
   cd /Users/atomasini/Development/mlx-manager/frontend
   npm install @rodrigodagostino/svelte-sortable-list
   ```

2. Create `frontend/src/lib/components/settings/RuleCard.svelte`:

**Props:**
- `rule: BackendMapping` - The rule to display
- `hasWarning: boolean` - Whether provider is unconfigured
- `onDelete: () => void` - Delete callback

**Display:**
- Left: Drag handle (GripVertical icon)
- Center:
  - Badge showing pattern_type (exact/prefix/regex)
  - Pattern value in monospace font (truncated if long)
  - Warning badge if hasWarning (with AlertTriangle icon)
  - "Routes to {backend_type}" text with fallback info
- Right: Delete button (Trash2 icon)

**Styling:**
- Card with border and padding
- Hover state for interactivity
- Muted colors for disabled rules
- Warning badge is yellow/orange

```svelte
<script lang="ts">
  import { Card, Badge } from '$components/ui';
  import { GripVertical, Trash2, AlertTriangle } from 'lucide-svelte';
  import type { BackendMapping } from '$lib/api/types';

  interface Props {
    rule: BackendMapping;
    hasWarning?: boolean;
    onDelete: () => void;
  }

  let { rule, hasWarning = false, onDelete }: Props = $props();

  const patternTypeColors: Record<string, string> = {
    exact: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200',
    prefix: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200',
    regex: 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200',
  };
</script>

<div class="flex items-center gap-3 p-4 bg-white dark:bg-gray-800 border rounded-lg shadow-sm {!rule.enabled ? 'opacity-50' : ''}">
  <!-- Drag handle -->
  <div class="cursor-grab text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
    <GripVertical class="h-5 w-5" />
  </div>

  <!-- Pattern info -->
  <div class="flex-1 min-w-0">
    <div class="flex items-center gap-2 flex-wrap">
      <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium {patternTypeColors[rule.pattern_type]}">
        {rule.pattern_type}
      </span>
      <code class="text-sm font-mono truncate max-w-xs">{rule.model_pattern}</code>
      {#if hasWarning}
        <span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs font-medium bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200">
          <AlertTriangle class="h-3 w-3" />
          Unconfigured
        </span>
      {/if}
    </div>
    <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">
      Routes to <span class="font-medium capitalize">{rule.backend_type}</span>
      {#if rule.backend_model}
        <span class="text-xs">as {rule.backend_model}</span>
      {/if}
      {#if rule.fallback_backend}
        <span class="text-xs">(fallback: {rule.fallback_backend})</span>
      {/if}
    </p>
  </div>

  <!-- Actions -->
  <button
    onclick={onDelete}
    class="p-2 text-gray-400 hover:text-red-500 transition-colors"
    title="Delete rule"
  >
    <Trash2 class="h-4 w-4" />
  </button>
</div>
```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/frontend
npm run check
```
  </verify>
  <done>
svelte-sortable-list installed, RuleCard component renders rule info with drag handle, pattern badge, warning badge when applicable, delete button, TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RuleForm and RuleTestInput components</name>
  <files>
    frontend/src/lib/components/settings/RuleForm.svelte
    frontend/src/lib/components/settings/RuleTestInput.svelte
  </files>
  <action>
Create the rule creation form and test input components:

1. Create `frontend/src/lib/components/settings/RuleForm.svelte`:

**Props:**
- `onSave: (rule: BackendMapping) => void` - Called after successful save
- `configuredProviders: BackendType[]` - List of configured providers

**Form fields:**
- Pattern type: Select dropdown (exact/prefix/regex)
- Pattern value: Text input with placeholder examples
- Backend type: Select dropdown (local/openai/anthropic)
- Backend model (optional): Text input for model alias
- Fallback backend (optional): Select dropdown

**Behavior:**
- Validate pattern is not empty
- Show warning if selected backend is not in configuredProviders (but still allow save)
- Clear form after successful save
- Loading state during save

```svelte
<script lang="ts">
  import { settings } from '$lib/api/client';
  import { Button, Input, Select } from '$components/ui';
  import { Plus, Loader2 } from 'lucide-svelte';
  import type { BackendType, PatternType, BackendMappingCreate } from '$lib/api/types';

  interface Props {
    onSave: () => void;
    configuredProviders: BackendType[];
  }

  let { onSave, configuredProviders }: Props = $props();

  let patternType = $state<PatternType>('exact');
  let patternValue = $state('');
  let backendType = $state<BackendType>('local');
  let backendModel = $state('');
  let fallbackBackend = $state<BackendType | ''>('');
  let saving = $state(false);
  let error = $state<string | null>(null);

  const showWarning = $derived(
    backendType !== 'local' && !configuredProviders.includes(backendType)
  );

  async function handleSubmit() {
    if (!patternValue.trim()) {
      error = 'Pattern is required';
      return;
    }
    saving = true;
    error = null;
    try {
      await settings.createRule({
        pattern_type: patternType,
        model_pattern: patternValue.trim(),
        backend_type: backendType,
        backend_model: backendModel.trim() || undefined,
        fallback_backend: fallbackBackend || undefined,
      });
      // Reset form
      patternValue = '';
      backendModel = '';
      fallbackBackend = '';
      onSave();
    } catch (e) {
      error = e instanceof Error ? e.message : 'Failed to create rule';
    } finally {
      saving = false;
    }
  }
</script>
```

2. Create `frontend/src/lib/components/settings/RuleTestInput.svelte`:

**Props:**
- `rules: BackendMapping[]` - Current rules list

**UI:**
- Text input for model name
- Test button
- Result display showing matched rule or "No rule matched (routes to local)"

**Behavior:**
- Call `settings.testRule(modelName)` on test
- Display result with matched rule ID and backend type
- Highlight the matched rule in the list (optional, via callback)

```svelte
<script lang="ts">
  import { settings } from '$lib/api/client';
  import { Button, Input } from '$components/ui';
  import { Search, Loader2 } from 'lucide-svelte';
  import type { RuleTestResult, BackendMapping } from '$lib/api/types';

  interface Props {
    rules: BackendMapping[];
  }

  let { rules }: Props = $props();

  let modelName = $state('');
  let testing = $state(false);
  let result = $state<RuleTestResult | null>(null);

  const matchedRule = $derived(
    result?.matched_rule_id ? rules.find(r => r.id === result.matched_rule_id) : null
  );

  async function handleTest() {
    if (!modelName.trim()) return;
    testing = true;
    result = null;
    try {
      result = await settings.testRule(modelName.trim());
    } finally {
      testing = false;
    }
  }
</script>

<div class="flex gap-2 items-start">
  <div class="flex-1">
    <input
      type="text"
      bind:value={modelName}
      placeholder="Enter model name to test (e.g., gpt-4, claude-3)"
      class="w-full rounded-md border border-gray-300 dark:border-gray-600 px-3 py-2 text-sm"
      onkeydown={(e) => e.key === 'Enter' && handleTest()}
    />
  </div>
  <button
    onclick={handleTest}
    disabled={testing || !modelName.trim()}
    class="px-4 py-2 bg-mlx-500 text-white rounded-md hover:bg-mlx-600 disabled:opacity-50 flex items-center gap-2"
  >
    {#if testing}
      <Loader2 class="h-4 w-4 animate-spin" />
    {:else}
      <Search class="h-4 w-4" />
    {/if}
    Test
  </button>
</div>

{#if result}
  <div class="mt-2 p-3 rounded-md {matchedRule ? 'bg-green-50 dark:bg-green-900/20' : 'bg-gray-50 dark:bg-gray-800'}">
    {#if matchedRule}
      <p class="text-sm">
        <span class="font-medium">Matched:</span>
        <code class="mx-1 px-1 bg-gray-100 dark:bg-gray-700 rounded">{matchedRule.model_pattern}</code>
        <span class="text-gray-500">-></span>
        <span class="font-medium capitalize">{result.backend_type}</span>
      </p>
    {:else}
      <p class="text-sm text-gray-600 dark:text-gray-400">
        No rule matched. Routes to <span class="font-medium">local</span> (default).
      </p>
    {/if}
  </div>
{/if}
```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/frontend
npm run check
```
  </verify>
  <done>
RuleForm component creates rules with all fields, shows warning for unconfigured providers. RuleTestInput tests model names and displays results. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RoutingRulesSection with drag-drop</name>
  <files>
    frontend/src/lib/components/settings/RoutingRulesSection.svelte
    frontend/src/lib/components/settings/index.ts
  </files>
  <action>
Create the main routing rules section with drag-drop sortable list:

1. Create `frontend/src/lib/components/settings/RoutingRulesSection.svelte`:

**Imports:**
```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { SortableList, sortItems } from '@rodrigodagostino/svelte-sortable-list';
  import { settings } from '$lib/api/client';
  import type { BackendMapping, CloudCredential, BackendType } from '$lib/api/types';
  import RuleCard from './RuleCard.svelte';
  import RuleForm from './RuleForm.svelte';
  import RuleTestInput from './RuleTestInput.svelte';
```

**State:**
- `rules: BackendMapping[]` - Loaded rules
- `credentials: CloudCredential[]` - For determining warnings
- `loading: boolean` - Initial load state
- `reordering: boolean` - During drag-drop save

**Logic:**
- Load rules and credentials on mount
- `configuredProviders` derived from credentials
- `hasWarning(rule)` checks if rule.backend_type not in configuredProviders (and not 'local')
- On drag-drop end:
  1. Reorder local array with `sortItems()`
  2. Recalculate priorities (top = highest)
  3. Call `settings.updateRulePriorities()`
- On delete: Call `settings.deleteRule()` and reload
- Show empty state if no rules

**Layout:**
- RuleTestInput at top
- "Add Rule" form (collapsible or always visible)
- Sortable list of RuleCards
- Loading spinner during operations

```svelte
<script lang="ts">
  // ... imports and state ...

  let rules = $state<BackendMapping[]>([]);
  let credentials = $state<CloudCredential[]>([]);
  let loading = $state(true);
  let reordering = $state(false);

  const configuredProviders = $derived(
    credentials.map(c => c.backend_type)
  );

  function hasWarning(rule: BackendMapping): boolean {
    return rule.backend_type !== 'local' && !configuredProviders.includes(rule.backend_type);
  }

  async function loadData() {
    loading = true;
    try {
      [rules, credentials] = await Promise.all([
        settings.listRules(),
        settings.listProviders(),
      ]);
    } finally {
      loading = false;
    }
  }

  onMount(loadData);

  async function handleDragEnd(e: { detail: { from: number; to: number } }) {
    const { from, to } = e.detail;
    if (from === to) return;

    // Optimistic update
    rules = sortItems(rules, from, to);

    // Calculate new priorities (top = highest)
    const priorities = rules.map((rule, index) => ({
      id: rule.id,
      priority: rules.length - index,
    }));

    reordering = true;
    try {
      await settings.updateRulePriorities(priorities);
    } catch {
      // Reload on error to restore correct order
      await loadData();
    } finally {
      reordering = false;
    }
  }

  async function handleDelete(ruleId: number) {
    if (!confirm('Delete this routing rule?')) return;
    await settings.deleteRule(ruleId);
    await loadData();
  }
</script>
```

**Note on SortableList API:** Check the library documentation for exact event names. It might be `on:sort` or `ondragend` or similar. The key is:
- Get the from/to indices
- Use `sortItems()` helper to reorder array
- Persist new priorities to backend

2. Update `frontend/src/lib/components/settings/index.ts`:
   ```typescript
   export { default as ProviderSection } from './ProviderSection.svelte';
   export { default as ProviderForm } from './ProviderForm.svelte';
   export { default as ModelPoolSettings } from './ModelPoolSettings.svelte';
   export { default as RoutingRulesSection } from './RoutingRulesSection.svelte';
   export { default as RuleCard } from './RuleCard.svelte';
   export { default as RuleForm } from './RuleForm.svelte';
   export { default as RuleTestInput } from './RuleTestInput.svelte';
   ```
  </action>
  <verify>
```bash
cd /Users/atomasini/Development/mlx-manager/frontend
npm run check
npm run lint
```
  </verify>
  <done>
RoutingRulesSection renders sortable list of RuleCards, drag-drop reorders and persists priorities, RuleForm creates new rules, RuleTestInput tests matching, warnings shown for unconfigured providers, TypeScript and ESLint pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
cd /Users/atomasini/Development/mlx-manager/frontend

# Type checking
npm run check

# Linting
npm run lint

# Verify package.json has new dependency
grep "svelte-sortable-list" package.json

# Verify components exist
ls -la src/lib/components/settings/
```

Manual verification:
1. Start dev servers: `./scripts/dev.sh`
2. Navigate to http://localhost:5173/settings
3. Scroll to Routing Rules section
4. Create a new rule with pattern "gpt-*", type "prefix", backend "openai"
5. Create another rule with pattern "claude-*"
6. Drag the second rule above the first
7. Verify priority persists (refresh page)
8. Test with model name "gpt-4" - should match first rule
9. Delete a rule
</verification>

<success_criteria>
- [ ] svelte-sortable-list installed
- [ ] RuleCard displays pattern, type badge, backend, warning if needed
- [ ] Drag handle allows reordering cards
- [ ] Priority updates persist to backend on reorder
- [ ] RuleForm creates new rules with all fields
- [ ] RuleTestInput tests model names and shows results
- [ ] Warning badge shows for unconfigured providers
- [ ] All TypeScript compiles, ESLint passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-configuration-ui/11-04-SUMMARY.md`
</output>
