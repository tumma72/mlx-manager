---
phase: 15-code-cleanup-integration-tests
plan: 14
type: execute
wave: 5
depends_on: []
files_modified:
  - backend/mlx_manager/services/hf_client.py
  - backend/mlx_manager/routers/models.py
  - backend/mlx_manager/models.py
  - backend/mlx_manager/main.py
  - backend/tests/test_download_management.py
  - frontend/src/lib/api/client.ts
  - frontend/src/lib/api/types.ts
  - frontend/src/lib/stores/downloads.svelte.ts
  - frontend/src/lib/components/models/DownloadProgressTile.svelte
autonomous: false

must_haves:
  truths:
    - "Users can pause an active download and it stops consuming bandwidth"
    - "Users can resume a paused download from where it left off"
    - "When the app restarts, paused downloads show as resumable in the UI"
    - "Users can cancel a download, which removes partial files from HF cache"
    - "The Download database record tracks paused/cancelled states"
    - "DownloadProgressTile shows pause, resume, and cancel buttons"
  artifacts:
    - path: "backend/mlx_manager/routers/models.py"
      provides: "POST /api/models/download/{id}/pause, /resume, /cancel endpoints"
    - path: "backend/mlx_manager/services/hf_client.py"
      provides: "Download cancellation via threading.Event and partial file cleanup"
    - path: "frontend/src/lib/components/models/DownloadProgressTile.svelte"
      provides: "Pause, Resume, and Cancel buttons on download tiles"
  key_links:
    - from: "DownloadProgressTile.svelte"
      to: "downloads.svelte.ts"
      via: "pauseDownload(), resumeDownload(), cancelDownload()"
    - from: "downloads.svelte.ts"
      to: "routers/models.py"
      via: "POST /api/models/download/{id}/pause|resume|cancel"
---

<objective>
Add pause, resume, and cancel buttons to model download tiles so users can manage long-running downloads.

Purpose: Large model downloads (10-30GB+) can take hours. Users need to pause when leaving, resume when returning, and cancel if they change their mind. The system should persist download state across restarts and clean up partial files on cancel.

Output: Three new backend endpoints + three new UI buttons on DownloadProgressTile, with proper state persistence and HF cache cleanup.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/mlx_manager/services/hf_client.py
@backend/mlx_manager/routers/models.py
@backend/mlx_manager/models.py
@backend/mlx_manager/main.py
@backend/mlx_manager/database.py
@frontend/src/lib/stores/downloads.svelte.ts
@frontend/src/lib/components/models/DownloadProgressTile.svelte
@frontend/src/lib/api/client.ts
</context>

<prerequisite>
Before starting, understand the HuggingFace Hub cache structure:

```bash
# Examine a partially downloaded model
ls -la ~/.cache/huggingface/hub/models--mlx-community--*/
# Look for .incomplete files, .locks, blobs, snapshots
```

Also investigate the `huggingface_hub` API:
```python
from huggingface_hub import scan_cache_dir, HfApi
cache = scan_cache_dir()
for repo in cache.repos:
    print(repo.repo_id, repo.size_on_disk)
    for revision in repo.revisions:
        print(f"  {revision.commit_hash}: {revision.size_on_disk}")

# Check if delete_cache_item exists
help(cache.delete_revisions)
```

Key facts about HF Hub downloads:
- `snapshot_download()` blocks the calling thread
- Partial files tracked via `.incomplete` suffix in blobs/
- Automatic resume: calling `snapshot_download()` again picks up where it left off
- No native pause API — must kill the thread
- Cache cleanup: `scan_cache_dir().delete_revisions([hash])` or manual deletion
</prerequisite>

<tasks>

<task type="interactive">
  <name>Task 1: Add download state fields and cancellation infrastructure</name>
  <files>
    backend/mlx_manager/models.py
    backend/mlx_manager/services/hf_client.py
  </files>
  <action>
    1. Update the `Download` model in `models.py` to support paused/cancelled states:
       - Add "paused" and "cancelled" to the valid status values
       - Status flow: pending → downloading → paused → downloading → completed
       - Status flow: pending/downloading/paused → cancelled

    2. Create a download cancellation mechanism in `hf_client.py`:
       - Add a module-level dict to track cancellation events per download:
         ```python
         import threading
         _cancel_events: dict[str, threading.Event] = {}
         ```

       - Add functions to manage cancel events:
         ```python
         def register_cancel_event(download_id: str) -> threading.Event:
             """Register a cancellation event for a download."""
             event = threading.Event()
             _cancel_events[download_id] = event
             return event

         def request_cancel(download_id: str) -> bool:
             """Signal a download to cancel. Returns True if event found."""
             event = _cancel_events.get(download_id)
             if event:
                 event.set()
                 return True
             return False

         def cleanup_cancel_event(download_id: str):
             """Remove cancel event after download completes/cancels."""
             _cancel_events.pop(download_id, None)
         ```

    3. Modify the `download_model()` method to check the cancel event:
       - Accept a `cancel_event: threading.Event | None` parameter
       - In the progress polling loop (the `while` loop that polls directory size),
         check `cancel_event.is_set()` each iteration
       - If cancellation is detected, kill the download executor and yield a "cancelled" status
       - Important: The actual `snapshot_download()` runs in a thread via `run_in_executor()`,
         so we need to track the Future and cancel it

    4. Add a function to clean up partial downloads from HF cache:
       ```python
       def cleanup_partial_download(model_id: str) -> bool:
           """Remove all partial download files for a model from HF cache.

           Uses huggingface_hub's cache management to safely delete partial data.
           """
           try:
               from huggingface_hub import scan_cache_dir
               cache = scan_cache_dir()
               for repo in cache.repos:
                   if repo.repo_id == model_id:
                       # Delete all revisions for this model
                       delete_strategy = cache.delete_revisions(
                           [rev.commit_hash for rev in repo.revisions]
                       )
                       delete_strategy.execute()
                       logger.info(f"Cleaned up {delete_strategy.expected_freed_size_str} for {model_id}")
                       return True
               return False
           except Exception as e:
               logger.error(f"Failed to clean up {model_id}: {e}")
               # Fallback: manual deletion of the cache directory
               import shutil
               cache_dir = Path.home() / ".cache" / "huggingface" / "hub" / f"models--{model_id.replace('/', '--')}"
               if cache_dir.exists():
                   shutil.rmtree(cache_dir)
                   logger.info(f"Manually cleaned up {cache_dir}")
                   return True
               return False
       ```
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    python -c "
    from mlx_manager.services.hf_client import register_cancel_event, request_cancel
    event = register_cancel_event('test-123')
    assert not event.is_set()
    request_cancel('test-123')
    assert event.is_set()
    print('Cancel event mechanism works')
    "
    ```
  </verify>
  <done>Download cancellation infrastructure with threading events and HF cache cleanup</done>
</task>

<task type="interactive">
  <name>Task 2: Create pause, resume, and cancel API endpoints</name>
  <files>backend/mlx_manager/routers/models.py</files>
  <action>
    Add three new endpoints to the models router:

    1. **POST /api/models/download/{download_id}/pause**
       - Find the download record by ID
       - Verify status is "downloading"
       - Signal the download thread to stop (via cancel event)
       - Update status to "paused" in database
       - The HF Hub will leave `.incomplete` files in place for later resume
       - Return the updated download record

    2. **POST /api/models/download/{download_id}/resume**
       - Find the download record by ID
       - Verify status is "paused"
       - Update status to "downloading" in database
       - Create a new background task that calls `hf_client.download_model()` again
       - HF Hub's `snapshot_download()` automatically resumes from `.incomplete` files
       - Register a new SSE progress endpoint for the resumed download
       - Return the new task_id for SSE reconnection

    3. **POST /api/models/download/{download_id}/cancel**
       - Find the download record by ID
       - Verify status is "downloading" or "paused"
       - If downloading: signal the thread to stop (via cancel event)
       - Update status to "cancelled" in database
       - Call `cleanup_partial_download(model_id)` to remove partial files
       - Remove any `.incomplete` files and cache blobs
       - Return success confirmation

    Error handling:
    - 404 if download_id not found
    - 409 if download is in wrong state for the action (e.g., pause a completed download)
    - 500 if cleanup fails (but still mark as cancelled)
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    # Verify routes are registered
    python -c "
    from mlx_manager.main import app
    routes = [r.path for r in app.routes]
    for r in sorted(routes):
        if 'download' in r:
            print(r)
    "
    ```
  </verify>
  <done>Pause, resume, and cancel endpoints created with proper state management</done>
</task>

<task type="interactive">
  <name>Task 3: Update main.py download recovery to handle paused state</name>
  <files>
    backend/mlx_manager/main.py
    backend/mlx_manager/database.py
  </files>
  <action>
    1. Update `recover_incomplete_downloads()` in `database.py`:
       - Currently recovers "pending" and "downloading" status
       - Change "downloading" to also recover as "paused" (since the download was interrupted)
       - Do NOT auto-resume paused downloads on startup — let the user decide
       - Only auto-resume downloads that were actively "downloading" when interrupted

    2. Update `resume_pending_downloads()` in `main.py`:
       - Keep auto-resume for downloads that were "downloading" (server crashed mid-download)
       - For downloads in "paused" state: leave them paused, don't auto-resume
       - Ensure paused downloads appear in `GET /api/models/downloads/active` so the
         frontend can show them with a "Resume" button

    3. Update `GET /api/models/downloads/active` endpoint in `routers/models.py`:
       - Include "paused" downloads in the active downloads response
       - Frontend needs to know about paused downloads to show resume buttons
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    pytest tests/ -v -k "download"
    ```
  </verify>
  <done>Download recovery handles paused state correctly on server restart</done>
</task>

<task type="interactive">
  <name>Task 4: Add download management methods to frontend store and API client</name>
  <files>
    frontend/src/lib/api/client.ts
    frontend/src/lib/api/types.ts
    frontend/src/lib/stores/downloads.svelte.ts
  </files>
  <action>
    1. Add API methods to `client.ts`:
       ```typescript
       async pauseDownload(downloadId: number): Promise<void> {
           await this.post(`/api/models/download/${downloadId}/pause`);
       }

       async resumeDownload(downloadId: number): Promise<{ task_id: string }> {
           return this.post(`/api/models/download/${downloadId}/resume`);
       }

       async cancelDownload(downloadId: number): Promise<void> {
           await this.post(`/api/models/download/${downloadId}/cancel`);
       }
       ```

    2. Update types in `types.ts`:
       - Add "paused" and "cancelled" to download status type
       - Add `download_id` to DownloadState if not already present

    3. Add store methods in `downloads.svelte.ts`:
       ```typescript
       async pauseDownload(modelId: string) {
           const state = this.downloads.get(modelId);
           if (!state?.download_id) return;

           await apiClient.pauseDownload(state.download_id);

           // Close SSE connection (download is paused)
           const eventSource = this.eventSources.get(modelId);
           if (eventSource) {
               eventSource.close();
               this.eventSources.delete(modelId);
           }

           // Update local state
           this.downloads.set(modelId, { ...state, status: 'paused' });
       }

       async resumeDownload(modelId: string) {
           const state = this.downloads.get(modelId);
           if (!state?.download_id) return;

           const { task_id } = await apiClient.resumeDownload(state.download_id);

           // Reconnect SSE with new task_id
           this.downloads.set(modelId, { ...state, status: 'downloading' });
           this.connectSSE(modelId, task_id);
       }

       async cancelDownload(modelId: string) {
           const state = this.downloads.get(modelId);
           if (!state?.download_id) return;

           await apiClient.cancelDownload(state.download_id);

           // Close SSE and remove from store
           const eventSource = this.eventSources.get(modelId);
           if (eventSource) {
               eventSource.close();
               this.eventSources.delete(modelId);
           }

           this.downloads.delete(modelId);
       }
       ```
  </action>
  <verify>
    ```bash
    cd frontend
    npm run check
    npm run lint
    ```
  </verify>
  <done>Frontend store and API client support pause, resume, and cancel actions</done>
</task>

<task type="interactive">
  <name>Task 5: Add pause, resume, and cancel buttons to DownloadProgressTile</name>
  <files>frontend/src/lib/components/models/DownloadProgressTile.svelte</files>
  <action>
    Update DownloadProgressTile to add action buttons based on download state:

    1. Add button row below the progress bar:
       - **When downloading**: Show [Pause] and [Cancel] buttons
       - **When paused**: Show [Resume] and [Cancel] buttons
       - **When completed**: No action buttons (or show a dismiss button)
       - **When failed**: Show [Retry] and [Cancel] buttons
       - **When cancelled**: Remove tile from display (handled in store)

    2. Button styling:
       - Pause: Muted/secondary style, pause icon
       - Resume: Primary/accent style, play icon
       - Cancel: Destructive/danger style, X icon
       - All buttons should be small to fit in the tile layout

    3. Cancel confirmation:
       - Show a brief confirmation before cancelling (modal or inline confirmation)
       - "Cancel download? This will remove all downloaded data for this model."
       - Confirm / Keep downloading buttons

    4. Handle loading states:
       - While pause/resume/cancel API call is in flight, disable buttons
       - Show brief spinner on the clicked button

    5. Wire up event handlers:
       ```svelte
       <script>
         import { downloadsStore } from '$lib/stores/downloads.svelte';

         let { download } = $props();
         let isLoading = $state(false);

         async function handlePause() {
             isLoading = true;
             try {
                 await downloadsStore.pauseDownload(download.model_id);
             } finally {
                 isLoading = false;
             }
         }

         async function handleResume() {
             isLoading = true;
             try {
                 await downloadsStore.resumeDownload(download.model_id);
             } finally {
                 isLoading = false;
             }
         }

         async function handleCancel() {
             if (!confirm('Cancel download? This will remove all downloaded data for this model.')) {
                 return;
             }
             isLoading = true;
             try {
                 await downloadsStore.cancelDownload(download.model_id);
             } finally {
                 isLoading = false;
             }
         }
       </script>
       ```

    6. Visual state indicators:
       - Downloading: Animated progress bar (existing)
       - Paused: Static/striped progress bar, "Paused" label, muted colors
       - Cancelled: Briefly show "Cancelled" then remove
  </action>
  <verify>
    ```bash
    cd frontend
    npm run check
    npm run lint
    npm run test
    ```
  </verify>
  <done>DownloadProgressTile has pause, resume, and cancel buttons with proper state handling</done>
</task>

<task type="interactive">
  <name>Task 6: Create unit tests for download management</name>
  <files>backend/tests/test_download_management.py</files>
  <action>
    Create tests covering:

    1. **Cancel event mechanism**:
       - register_cancel_event creates event
       - request_cancel sets the event
       - cleanup_cancel_event removes it
       - request_cancel on unknown ID returns False

    2. **Pause endpoint**:
       - Pausing a downloading download sets status to "paused"
       - Pausing a non-downloading download returns 409
       - Pausing unknown download_id returns 404

    3. **Resume endpoint**:
       - Resuming a paused download sets status to "downloading"
       - Returns a new task_id for SSE reconnection
       - Resuming non-paused download returns 409

    4. **Cancel endpoint**:
       - Cancelling a downloading download sets status to "cancelled"
       - Cancelling a paused download sets status to "cancelled"
       - Cleanup function is called
       - Cancelling completed download returns 409

    5. **Cache cleanup** (mocked):
       - cleanup_partial_download uses HF cache API
       - Falls back to shutil.rmtree on error
       - Returns False when model not in cache

    6. **Recovery on restart**:
       - "downloading" downloads auto-resume
       - "paused" downloads stay paused
       - "cancelled" downloads stay cancelled

    All tests should use mocking for HF Hub operations.
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    pytest tests/test_download_management.py -v
    # Full test suite
    pytest -v
    ```
  </verify>
  <done>Unit tests for pause/resume/cancel download management</done>
</task>

</tasks>

<verification>
1. Backend endpoints exist:
   ```bash
   python -c "from mlx_manager.main import app; print([r.path for r in app.routes if 'download' in r.path])"
   ```
   Should include: .../pause, .../resume, .../cancel

2. Frontend type checks pass:
   ```bash
   cd frontend && npm run check
   ```

3. Unit tests pass:
   ```bash
   cd backend && pytest tests/test_download_management.py -v
   ```

4. Manual test flow:
   - Start a large model download (e.g., gemma-3-27b)
   - Click Pause → download stops, progress bar shows "Paused"
   - Click Resume → download continues from same progress
   - Click Cancel → partial files cleaned up, tile disappears
   - Start download, close browser, reopen → paused downloads show with Resume button

5. Full test suite:
   ```bash
   cd backend && pytest -v
   cd frontend && npm run test
   ```
</verification>

<success_criteria>
- POST /api/models/download/{id}/pause stops active download and persists "paused" status
- POST /api/models/download/{id}/resume continues download from where it left off
- POST /api/models/download/{id}/cancel stops download and cleans up all partial files from HF cache
- Paused downloads survive server restart and show as resumable in UI
- DownloadProgressTile shows contextual buttons: Pause+Cancel when downloading, Resume+Cancel when paused
- Cancel shows confirmation before proceeding
- Unit tests cover all state transitions and edge cases
- HuggingFace Hub's automatic resume mechanism is leveraged (no re-downloading already completed files)
</success_criteria>

<output>
After completion, create `.planning/phases/15-code-cleanup-integration-tests/15-14-SUMMARY.md`
</output>
