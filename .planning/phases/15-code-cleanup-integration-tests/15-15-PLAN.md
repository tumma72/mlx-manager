---
phase: 15-code-cleanup-integration-tests
plan: 15
type: execute
wave: 5
depends_on: []
files_modified:
  - backend/pyproject.toml
  - backend/mlx_manager/services/encryption_service.py
  - backend/mlx_manager/services/auth_service.py
  - backend/mlx_manager/models.py
  - backend/tests/test_encryption_service.py
  - backend/tests/test_auth_service.py
autonomous: false

must_haves:
  truths:
    - "Server starts without ModuleNotFoundError for cryptography"
    - "API key encryption/decryption works using AuthLib JWE (not Fernet)"
    - "JWT token signing/verification works using AuthLib jose (not pyjwt)"
    - "Password hashing still uses pwdlib[argon2] (no change)"
    - "pyjwt removed from dependencies"
    - "cryptography only present as transitive dep of authlib, not direct"
    - "Existing encrypted API keys are migrated or users notified to re-enter"
    - "All existing tests pass with new auth stack"
  artifacts:
    - path: "backend/mlx_manager/services/encryption_service.py"
      provides: "API key encryption using AuthLib JWE with A256KW+A256GCM"
    - path: "backend/mlx_manager/services/auth_service.py"
      provides: "JWT tokens using AuthLib jose module"
    - path: "backend/pyproject.toml"
      provides: "AuthLib dependency, pyjwt removed"
  key_links:
    - from: "encryption_service.py"
      to: "routers/settings.py"
      via: "encrypt_api_key(), decrypt_api_key()"
      pattern: "from.*encryption_service import"
    - from: "auth_service.py"
      to: "routers/auth.py"
      via: "create_access_token(), decode_token()"
      pattern: "from.*auth_service import"
---

<objective>
Consolidate authentication and encryption under AuthLib as per the original architectural decision, fixing the server crash caused by missing `cryptography` dependency and eliminating redundant auth packages.

Purpose: The project's architecture documents (PROJECT.md, REQUIREMENTS.md, STATE.md) all specify AuthLib as the unified auth/crypto library. However, the implementation deviated: `encryption_service.py` uses `cryptography.fernet.Fernet` (which was never added to dependencies, causing a crash), and `auth_service.py` uses `pyjwt`. This plan realigns the implementation with the architectural decision.

Dependency changes:
- ADD: `authlib>=1.3.0` (provides JWT via jose module + JWE for symmetric encryption)
- REMOVE: `pyjwt>=2.8.0` (replaced by authlib.jose.jwt)
- KEEP: `pwdlib[argon2]>=0.3.0` (AuthLib does not provide password hashing)
- NOTE: `cryptography` becomes a transitive dep of authlib, no longer needed directly

Output: Working server with AuthLib-based JWT and JWE encryption, one less direct dependency.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md (line 99: AuthLib decision)
@.planning/REQUIREMENTS.md (line 59: CONF-01 AuthLib encryption)
@.planning/STATE.md (line 116: AuthLib consolidation)
@backend/mlx_manager/services/encryption_service.py
@backend/mlx_manager/services/auth_service.py
@backend/mlx_manager/routers/settings.py
@backend/mlx_manager/models.py
@backend/mlx_manager/config.py
@backend/tests/test_encryption_service.py
</context>

<prerequisite>
Before starting, investigate AuthLib's actual API for JWE and JWT:

```python
# Check AuthLib version and capabilities
import authlib
print(authlib.__version__)

# JWE symmetric encryption
from authlib.jose import JsonWebEncryption, OctKey

# Create a symmetric key from a secret
key = OctKey.generate_key('A256KW', is_private=True)
print(type(key), len(key.as_bytes()))

# Or derive from existing secret
import hashlib
secret = b"my-jwt-secret"
key_bytes = hashlib.sha256(secret).digest()  # 32 bytes for A256
key = OctKey.import_key(key_bytes)

# Encrypt
jwe = JsonWebEncryption()
protected = {'alg': 'A256KW', 'enc': 'A256GCM'}
token = jwe.serialize_compact(protected, b'my-api-key', key)
print("Encrypted:", token)

# Decrypt
data = jwe.deserialize_compact(token, key)
print("Decrypted:", data['payload'])

# JWT
from authlib.jose import jwt
header = {'alg': 'HS256'}
payload = {'sub': 'user@example.com', 'exp': 1234567890}
token = jwt.encode(header, payload, secret)
print("JWT:", token)
claims = jwt.decode(token, secret)
print("Claims:", claims)
```

Also check if `joserfc` (newer package from same author) would be better:
```python
# joserfc is the newer, more mature implementation
# pip install joserfc
from joserfc.jwe import encrypt_compact, decrypt_compact
from joserfc.jwk import OctKey
```

Choose between `authlib.jose` and `joserfc` based on maturity and API quality.
The plan below uses `authlib.jose` but the executor should adapt if `joserfc` is better.
</prerequisite>

<tasks>

<task type="interactive">
  <name>Task 1: Update dependencies — add AuthLib, remove pyjwt</name>
  <files>backend/pyproject.toml</files>
  <action>
    1. Add `authlib>=1.3.0` to the `dependencies` list in `pyproject.toml`.

    2. Remove `pyjwt>=2.8.0` from the `dependencies` list.

    3. Keep `pwdlib[argon2]>=0.3.0` (AuthLib doesn't do password hashing).

    4. Do NOT add `cryptography` directly — it comes as a transitive dep of authlib.

    5. Run `uv lock` to regenerate the lock file.

    6. Run `uv pip install -e ".[dev]"` to install the new dependencies.

    Verify:
    ```python
    import authlib.jose
    print("AuthLib jose available")

    # Verify cryptography is available (via authlib)
    import cryptography
    print(f"cryptography {cryptography.__version__} (transitive)")

    # Verify pyjwt is gone
    try:
        import jwt
        print("WARNING: pyjwt still installed!")
    except ImportError:
        print("pyjwt correctly removed")
    ```
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    uv lock && uv pip install -e ".[dev]"
    python -c "from authlib.jose import JsonWebEncryption, jwt; print('AuthLib ready')"
    ```
  </verify>
  <done>AuthLib added, pyjwt removed, lock file updated</done>
</task>

<task type="interactive">
  <name>Task 2: Rewrite encryption_service.py to use AuthLib JWE</name>
  <files>backend/mlx_manager/services/encryption_service.py</files>
  <action>
    Rewrite the encryption service to use AuthLib's JWE instead of cryptography's Fernet.

    Key design decisions:
    - Use `A256KW` (key wrapping) + `A256GCM` (content encryption) for strong symmetric encryption
    - Derive the 256-bit key from `jwt_secret` using SHA-256 (same secret, different derivation)
    - Use `OctKey` for the symmetric JWK
    - JWE tokens are URL-safe strings, suitable for database storage
    - Each encryption produces a different ciphertext (JWE includes random IV/nonce)

    Implementation:

    ```python
    """API key encryption service using AuthLib JWE.

    Encrypts cloud provider API keys for secure database storage using
    JSON Web Encryption (JWE) with symmetric key wrapping.

    Algorithm: A256KW (key wrap) + A256GCM (content encryption)
    Key derivation: SHA-256 of jwt_secret (consistent 256-bit key)
    """

    import hashlib
    from functools import lru_cache
    from loguru import logger

    from authlib.jose import JsonWebEncryption, OctKey

    from mlx_manager.config import get_settings


    _JWE_HEADER = {"alg": "A256KW", "enc": "A256GCM"}


    @lru_cache(maxsize=1)
    def _get_encryption_key() -> OctKey:
        """Derive a 256-bit symmetric key from jwt_secret.

        Uses SHA-256 for consistent key derivation.
        The key is cached for performance.
        """
        settings = get_settings()
        secret = settings.jwt_secret.encode("utf-8")
        key_bytes = hashlib.sha256(secret).digest()  # 32 bytes = 256 bits
        return OctKey.import_key(key_bytes)


    def encrypt_api_key(api_key: str) -> str:
        """Encrypt an API key using JWE compact serialization.

        Args:
            api_key: The plaintext API key to encrypt.

        Returns:
            JWE compact token (URL-safe string suitable for database storage).
        """
        key = _get_encryption_key()
        jwe = JsonWebEncryption()
        token = jwe.serialize_compact(_JWE_HEADER, api_key.encode("utf-8"), key)
        if isinstance(token, bytes):
            token = token.decode("utf-8")
        return token


    def decrypt_api_key(encrypted_key: str) -> str:
        """Decrypt an API key from JWE compact serialization.

        Args:
            encrypted_key: The JWE token to decrypt.

        Returns:
            The plaintext API key.

        Raises:
            Exception: If decryption fails (wrong key, tampered data, etc.)
        """
        key = _get_encryption_key()
        jwe = JsonWebEncryption()
        data = jwe.deserialize_compact(encrypted_key, key)
        payload = data["payload"]
        if isinstance(payload, bytes):
            return payload.decode("utf-8")
        return str(payload)


    def clear_cache():
        """Clear the cached encryption key. Useful for testing."""
        _get_encryption_key.cache_clear()
    ```

    Important notes:
    - The `.encryption_salt` file is NO LONGER NEEDED — JWE key derivation uses only jwt_secret
    - The `_get_encryption_key()` is simpler: SHA-256 of jwt_secret (no PBKDF2, no salt)
    - This is acceptable because jwt_secret should already be a high-entropy random string
    - If stronger key derivation is needed, PBKDF2 can be added back using hashlib.pbkdf2_hmac
      (stdlib, no extra deps)
    - JWE tokens are slightly longer than Fernet tokens but still fine for DB storage

    Migration note for existing data:
    - If there are existing Fernet-encrypted API keys in the database, they will fail to
      decrypt with the new JWE-based service
    - Since `cryptography` was NEVER in the dependencies (server couldn't start), it's unlikely
      anyone has stored encrypted keys. But to be safe, add a try/except in decrypt that logs
      a clear error message:
      ```python
      except Exception as e:
          logger.error(
              f"Failed to decrypt API key. If this was encrypted with a previous version, "
              f"please re-enter the API key in Settings. Error: {e}"
          )
          raise
      ```
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    python -c "
    from mlx_manager.services.encryption_service import encrypt_api_key, decrypt_api_key
    encrypted = encrypt_api_key('sk-test-12345')
    decrypted = decrypt_api_key(encrypted)
    assert decrypted == 'sk-test-12345'
    print(f'Encrypted: {encrypted[:50]}...')
    print(f'Decrypted: {decrypted}')
    print('JWE encryption works!')
    "
    ```
  </verify>
  <done>Encryption service rewritten to use AuthLib JWE with A256KW+A256GCM</done>
</task>

<task type="interactive">
  <name>Task 3: Rewrite auth_service.py to use AuthLib jose JWT</name>
  <files>backend/mlx_manager/services/auth_service.py</files>
  <action>
    Replace `import jwt` (pyjwt) with AuthLib's jose JWT module.

    Key changes:
    - `jwt.encode()` → `authlib_jwt.encode(header, payload, secret)`
    - `jwt.decode()` → `authlib_jwt.decode(token, secret)` with claims validation
    - Error handling: `jwt.ExpiredSignatureError` → check claims after decode
    - AuthLib returns `JWTClaims` object (dict-like) instead of plain dict

    Implementation changes in auth_service.py:

    ```python
    # Before:
    import jwt

    def create_access_token(data: dict, ...) -> str:
        payload = {**data, "exp": expire}
        return jwt.encode(payload, settings.jwt_secret, algorithm="HS256")

    def decode_token(token: str) -> dict:
        return jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])

    # After:
    from authlib.jose import jwt as authlib_jwt

    def create_access_token(data: dict, ...) -> str:
        header = {"alg": "HS256"}
        payload = {**data, "exp": expire}
        token = authlib_jwt.encode(header, payload, settings.jwt_secret)
        if isinstance(token, bytes):
            return token.decode("utf-8")
        return str(token)

    def decode_token(token: str) -> dict:
        claims = authlib_jwt.decode(token, settings.jwt_secret)
        claims.validate()  # Validates exp, nbf, iat, etc.
        return dict(claims)
    ```

    Error handling updates:
    - Replace `jwt.ExpiredSignatureError` with `authlib.jose.errors.ExpiredTokenError`
    - Replace `jwt.InvalidTokenError` with `authlib.jose.errors.DecodeError` or
      `authlib.jose.errors.BadSignatureError`
    - Or catch the base `Exception` from `claims.validate()` and map to HTTP 401

    Keep `pwdlib[argon2]` for password hashing — no change needed there.
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    python -c "
    from mlx_manager.services.auth_service import create_access_token, decode_token
    token = create_access_token({'sub': 'test@example.com'})
    claims = decode_token(token)
    assert claims['sub'] == 'test@example.com'
    print(f'Token: {token[:50]}...')
    print(f'Claims: {claims}')
    print('AuthLib JWT works!')
    "
    ```
  </verify>
  <done>JWT tokens now use AuthLib jose instead of pyjwt</done>
</task>

<task type="interactive">
  <name>Task 4: Update model comment and clean up salt file references</name>
  <files>
    backend/mlx_manager/models.py
  </files>
  <action>
    1. Update the comment on `encrypted_api_key` field (line 356):
       ```python
       # Before:
       encrypted_api_key: str  # Encrypted with AuthLib

       # After:
       encrypted_api_key: str  # Encrypted with AuthLib JWE (A256KW+A256GCM)
       ```

    2. Remove any references to `.encryption_salt` file in the codebase:
       - The salt file is no longer needed (JWE uses SHA-256 of jwt_secret directly)
       - Search for references to `encryption_salt` and remove them
       - The `backend/.encryption_salt` file itself can be deleted (it's in .gitignore)
       - If there's salt generation code in the encryption service, it was already removed
         in Task 2

    3. Search for any remaining `import jwt` (bare pyjwt imports) across the codebase
       and ensure they're all replaced with `from authlib.jose import jwt`.
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    # Check no bare jwt imports remain
    grep -rn "import jwt$" mlx_manager/ || echo "No bare jwt imports found"
    # Check no cryptography imports remain (except in comments/tests)
    grep -rn "from cryptography" mlx_manager/ || echo "No cryptography imports found"
    # Check salt references
    grep -rn "encryption_salt" mlx_manager/ || echo "No salt references found"
    ```
  </verify>
  <done>Comments updated, salt references removed, no stale imports</done>
</task>

<task type="interactive">
  <name>Task 5: Update tests for new auth stack</name>
  <files>
    backend/tests/test_encryption_service.py
    backend/tests/test_auth_service.py
  </files>
  <action>
    1. Update `test_encryption_service.py`:
       - Keep all test scenarios (roundtrip, special chars, long keys, tampered data)
       - Update expected error types for tampered/invalid tokens
       - Remove any references to Fernet, PBKDF2, salt
       - Add test for JWE-specific behavior:
         - Same plaintext produces different ciphertexts (JWE has random nonce)
         - Encrypted output is valid JWE compact format (5 base64url parts separated by dots)

    2. Update `test_auth_service.py` (if it exists):
       - Update expected error types for expired/invalid tokens
       - Remove any pyjwt-specific assertions
       - Add test for AuthLib JWT claims validation

    3. Verify all existing test scenarios still pass with new implementation.

    4. Run the full test suite to catch any imports or usages of old packages.
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    pytest tests/test_encryption_service.py -v
    pytest tests/test_auth_service.py -v 2>/dev/null || echo "No auth service tests yet"
    # Full suite
    pytest -v
    ```
  </verify>
  <done>All tests updated and passing with AuthLib-based auth stack</done>
</task>

<task type="interactive">
  <name>Task 6: Verify server starts and quality gates pass</name>
  <files></files>
  <action>
    1. Start the server and verify no import errors:
       ```bash
       cd backend && source .venv/bin/activate
       uvicorn mlx_manager.main:app --port 10242 &
       sleep 3
       curl http://localhost:10242/api/system/health
       kill %1
       ```

    2. Run all quality gates:
       ```bash
       cd backend
       ruff check .
       ruff format --check .
       mypy mlx_manager
       pytest -v
       ```

    3. Verify the encryption roundtrip works via the actual Settings API:
       - Start server
       - POST a cloud credential with an API key
       - GET the credential back (should be encrypted in DB, decrypted in response)
       - Verify the API key matches

    4. Verify JWT auth works:
       - Create a user / login
       - Use the JWT token to access a protected endpoint
       - Verify the token is valid
  </action>
  <verify>
    ```bash
    cd backend && source .venv/bin/activate
    ruff check . && ruff format --check . && mypy mlx_manager && pytest -v
    ```
  </verify>
  <done>Server starts cleanly, all quality gates pass, auth stack verified end-to-end</done>
</task>

</tasks>

<verification>
1. Server starts without errors:
   ```bash
   cd backend && uvicorn mlx_manager.main:app --port 10242
   # Should see no ModuleNotFoundError or import errors
   ```

2. Encryption works:
   ```python
   from mlx_manager.services.encryption_service import encrypt_api_key, decrypt_api_key
   assert decrypt_api_key(encrypt_api_key("sk-test")) == "sk-test"
   ```

3. JWT works:
   ```python
   from mlx_manager.services.auth_service import create_access_token, decode_token
   token = create_access_token({"sub": "test@example.com"})
   assert decode_token(token)["sub"] == "test@example.com"
   ```

4. No old dependencies imported:
   ```bash
   grep -rn "from cryptography" mlx_manager/  # Should find nothing
   grep -rn "^import jwt$" mlx_manager/        # Should find nothing
   ```

5. Dependencies correct:
   ```bash
   grep "authlib" pyproject.toml    # Should be present
   grep "pyjwt" pyproject.toml      # Should NOT be present
   grep "cryptography" pyproject.toml  # Should NOT be present (it's transitive)
   ```

6. All tests pass:
   ```bash
   pytest -v
   ```

7. Quality gates pass:
   ```bash
   ruff check . && ruff format --check . && mypy mlx_manager
   ```
</verification>

<success_criteria>
- Server starts without `ModuleNotFoundError: No module named 'cryptography'`
- API key encryption uses AuthLib JWE (A256KW + A256GCM), not Fernet
- JWT token handling uses AuthLib jose, not pyjwt
- Password hashing unchanged (pwdlib[argon2])
- `authlib>=1.3.0` in dependencies
- `pyjwt` removed from dependencies
- `cryptography` not a direct dependency (transitive via authlib)
- No bare `import jwt` or `from cryptography` imports in mlx_manager/
- `.encryption_salt` file no longer needed
- All existing encryption tests pass with JWE
- All existing auth tests pass with AuthLib JWT
- Full test suite green, quality gates pass
- Implementation matches architectural decision in PROJECT.md and REQUIREMENTS.md
</success_criteria>

<output>
After completion, create `.planning/phases/15-code-cleanup-integration-tests/15-15-SUMMARY.md`
</output>
