---
phase: 12-production-hardening
plan: 05
type: execute
wave: 3
depends_on: ["12-04"]
files_modified:
  - backend/mlx_manager/mlx_server/api/v1/admin.py
  - backend/mlx_manager/mlx_server/api/v1/__init__.py
  - backend/mlx_manager/routers/system.py
  - frontend/src/lib/api/types.ts
  - frontend/src/lib/api/client.ts
  - frontend/src/lib/components/settings/AuditLogPanel.svelte
  - frontend/src/lib/components/settings/index.ts
  - frontend/src/routes/(protected)/settings/+page.svelte
autonomous: true

must_haves:
  truths:
    - "Admin panel displays request logs with infinite scroll"
    - "Logs are filterable by model, backend type, status, and time range"
    - "WebSocket provides live log updates"
    - "Each log entry shows: timestamp, model, backend, duration, status, tokens"
    - "Export functionality outputs standard log format"
  artifacts:
    - path: "backend/mlx_manager/mlx_server/api/v1/admin.py"
      provides: "Admin API endpoints for logs and WebSocket"
      exports: ["router"]
    - path: "backend/mlx_manager/routers/system.py"
      provides: "WebSocket proxy endpoint for audit logs"
      contains: "ws/audit-logs"
    - path: "frontend/src/lib/components/settings/AuditLogPanel.svelte"
      provides: "Admin log panel UI component"
  key_links:
    - from: "frontend/AuditLogPanel.svelte"
      to: "backend/routers/system.py"
      via: "WebSocket connection through manager proxy"
      pattern: "/api/system/ws/audit-logs"
    - from: "backend/routers/system.py"
      to: "mlx_server/api/v1/admin.py"
      via: "WebSocket proxy to MLX Server"
      pattern: "websocket.*audit-logs"
    - from: "backend/api/v1/admin.py"
      to: "services/audit.py"
      via: "audit_service.subscribe() for WebSocket"
      pattern: "audit_service"
---

<objective>
Create admin panel UI for viewing and filtering audit logs

Purpose: PROD-04 requires an admin panel that displays request logs with filtering. Per CONTEXT.md: infinite scroll, essential filters (model, backend type, status, time range), WebSocket for live updates, standard log export.

Output: Settings page has Audit Logs section with filtering, live updates, and export
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-production-hardening/12-CONTEXT.md
@.planning/phases/12-production-hardening/12-RESEARCH.md
@backend/mlx_manager/mlx_server/api/v1/admin.py
@backend/mlx_manager/mlx_server/services/audit.py
@backend/mlx_manager/routers/system.py
@frontend/src/routes/(protected)/settings/+page.svelte
@frontend/src/lib/components/settings/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audit log API endpoints to MLX Server</name>
  <files>
    backend/mlx_manager/mlx_server/api/v1/admin.py
  </files>
  <action>
Update `backend/mlx_manager/mlx_server/api/v1/admin.py` to add audit log endpoints:

```python
"""Admin endpoints for MLX Server management."""

import asyncio
import json
import logging
from datetime import UTC, datetime

from fastapi import APIRouter, Query, WebSocket, WebSocketDisconnect
from sqlalchemy import func
from sqlmodel import select

from mlx_manager.mlx_server.database import get_session
from mlx_manager.mlx_server.models import pool
from mlx_manager.mlx_server.models.audit import AuditLog, AuditLogFilter, AuditLogResponse
from mlx_manager.mlx_server.services.audit import audit_service

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/admin", tags=["admin"])


# ============================================================================
# Existing admin endpoints (model management)
# ============================================================================

@router.get("/models")
async def list_loaded_models() -> list[dict]:
    """List all currently loaded models."""
    # ... existing implementation ...


@router.post("/models/{model_id}/preload")
async def preload_model(model_id: str) -> dict:
    """Preload a model into the pool."""
    # ... existing implementation ...


@router.delete("/models/{model_id}")
async def unload_model(model_id: str) -> dict:
    """Unload a model from the pool."""
    # ... existing implementation ...


# ============================================================================
# Audit log endpoints (new)
# ============================================================================

@router.get("/audit-logs", response_model=list[AuditLogResponse])
async def get_audit_logs(
    model: str | None = Query(default=None, description="Filter by model"),
    backend_type: str | None = Query(default=None, description="Filter by backend type"),
    status: str | None = Query(default=None, description="Filter by status"),
    start_time: datetime | None = Query(default=None, description="Start of time range"),
    end_time: datetime | None = Query(default=None, description="End of time range"),
    limit: int = Query(default=100, le=1000, description="Max results"),
    offset: int = Query(default=0, ge=0, description="Offset for pagination"),
) -> list[AuditLogResponse]:
    """Get audit logs with optional filtering.

    Supports filtering by:
    - model: Exact model name match
    - backend_type: local, openai, anthropic
    - status: success, error, timeout
    - start_time/end_time: Time range filter

    Returns most recent first (descending timestamp).
    """
    async with get_session() as session:
        query = select(AuditLog)

        # Apply filters
        if model:
            query = query.where(AuditLog.model == model)
        if backend_type:
            query = query.where(AuditLog.backend_type == backend_type)
        if status:
            query = query.where(AuditLog.status == status)
        if start_time:
            query = query.where(AuditLog.timestamp >= start_time)
        if end_time:
            query = query.where(AuditLog.timestamp <= end_time)

        # Order by timestamp descending (most recent first)
        query = query.order_by(AuditLog.timestamp.desc())

        # Apply pagination
        query = query.offset(offset).limit(limit)

        result = await session.execute(query)
        logs = result.scalars().all()

        return [AuditLogResponse.model_validate(log) for log in logs]


@router.get("/audit-logs/stats")
async def get_audit_stats() -> dict:
    """Get aggregate statistics for audit logs."""
    async with get_session() as session:
        # Total count
        total_result = await session.execute(select(func.count(AuditLog.id)))
        total = total_result.scalar() or 0

        # Count by status
        status_result = await session.execute(
            select(AuditLog.status, func.count(AuditLog.id))
            .group_by(AuditLog.status)
        )
        by_status = dict(status_result.all())

        # Count by backend
        backend_result = await session.execute(
            select(AuditLog.backend_type, func.count(AuditLog.id))
            .group_by(AuditLog.backend_type)
        )
        by_backend = dict(backend_result.all())

        # Unique models
        models_result = await session.execute(
            select(func.count(func.distinct(AuditLog.model)))
        )
        unique_models = models_result.scalar() or 0

        return {
            "total_requests": total,
            "by_status": by_status,
            "by_backend": by_backend,
            "unique_models": unique_models,
        }


@router.get("/audit-logs/export")
async def export_audit_logs(
    model: str | None = Query(default=None),
    backend_type: str | None = Query(default=None),
    status: str | None = Query(default=None),
    start_time: datetime | None = Query(default=None),
    end_time: datetime | None = Query(default=None),
    format: str = Query(default="jsonl", description="Export format: jsonl or csv"),
) -> str:
    """Export audit logs in JSONL or CSV format.

    JSONL format is standard and easily parseable by log tools.
    CSV format is useful for spreadsheet analysis.
    """
    from fastapi.responses import PlainTextResponse

    async with get_session() as session:
        query = select(AuditLog)

        if model:
            query = query.where(AuditLog.model == model)
        if backend_type:
            query = query.where(AuditLog.backend_type == backend_type)
        if status:
            query = query.where(AuditLog.status == status)
        if start_time:
            query = query.where(AuditLog.timestamp >= start_time)
        if end_time:
            query = query.where(AuditLog.timestamp <= end_time)

        query = query.order_by(AuditLog.timestamp.desc())
        result = await session.execute(query)
        logs = result.scalars().all()

        if format == "csv":
            import csv
            import io

            output = io.StringIO()
            if logs:
                fieldnames = [
                    "timestamp", "request_id", "model", "backend_type",
                    "endpoint", "duration_ms", "status",
                    "prompt_tokens", "completion_tokens", "total_tokens",
                    "error_type", "error_message",
                ]
                writer = csv.DictWriter(output, fieldnames=fieldnames)
                writer.writeheader()
                for log in logs:
                    row = log.model_dump()
                    row["timestamp"] = row["timestamp"].isoformat()
                    writer.writerow({k: row.get(k) for k in fieldnames})

            return PlainTextResponse(
                content=output.getvalue(),
                media_type="text/csv",
                headers={"Content-Disposition": "attachment; filename=audit-logs.csv"},
            )
        else:
            # JSONL format (default)
            lines = []
            for log in logs:
                data = log.model_dump()
                data["timestamp"] = data["timestamp"].isoformat()
                lines.append(json.dumps(data))

            return PlainTextResponse(
                content="\n".join(lines),
                media_type="application/jsonl",
                headers={"Content-Disposition": "attachment; filename=audit-logs.jsonl"},
            )


# ============================================================================
# WebSocket for live log updates
# ============================================================================

@router.websocket("/ws/audit-logs")
async def audit_log_stream(websocket: WebSocket) -> None:
    """WebSocket endpoint for real-time audit log streaming.

    Sends recent logs on connect, then streams new entries.
    """
    await websocket.accept()
    queue: asyncio.Queue[dict] = asyncio.Queue()

    def on_new_log(log: dict) -> None:
        """Callback when new log entry is created."""
        try:
            queue.put_nowait(log)
        except asyncio.QueueFull:
            pass  # Drop if queue is full

    # Subscribe to new logs
    audit_service.subscribe(on_new_log)

    try:
        # Send recent logs first
        for log in audit_service.get_recent_logs():
            await websocket.send_json({"type": "log", "data": log})

        # Stream new logs
        while True:
            try:
                log = await asyncio.wait_for(queue.get(), timeout=30.0)
                await websocket.send_json({"type": "log", "data": log})
            except asyncio.TimeoutError:
                # Send ping to keep connection alive
                await websocket.send_json({"type": "ping"})

    except WebSocketDisconnect:
        logger.debug("WebSocket client disconnected")
    finally:
        audit_service.unsubscribe(on_new_log)
```

Note: The existing admin endpoints (list_loaded_models, preload_model, unload_model) should remain - only add the new audit log endpoints and WebSocket.
  </action>
  <verify>
    - `python -c "from mlx_manager.mlx_server.api.v1.admin import router; print('OK')"`
    - `grep "audit-logs" backend/mlx_manager/mlx_server/api/v1/admin.py`
    - `grep "websocket" backend/mlx_manager/mlx_server/api/v1/admin.py`
  </verify>
  <done>Admin API has audit log endpoints and WebSocket</done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket proxy endpoint in manager API</name>
  <files>
    backend/mlx_manager/routers/system.py
  </files>
  <action>
The frontend connects to the manager (port 10242), not directly to the MLX Server (port 10242). Add a WebSocket proxy endpoint so the frontend can access audit log streaming through the manager.

Update `backend/mlx_manager/routers/system.py` to add a WebSocket proxy:

```python
# Add to imports
import httpx
from fastapi import WebSocket, WebSocketDisconnect

# Add WebSocket proxy endpoint
@router.websocket("/ws/audit-logs")
async def proxy_audit_log_stream(websocket: WebSocket) -> None:
    """Proxy WebSocket connection to MLX Server for audit log streaming.

    The frontend connects to the manager API (port 10242), not directly to
    the MLX Server (port 10242). This endpoint proxies the WebSocket
    connection to the MLX Server's audit log stream.
    """
    await websocket.accept()

    # Get MLX Server URL from settings or use default
    mlx_server_url = "ws://localhost:10242/admin/ws/audit-logs"

    try:
        async with httpx.AsyncClient() as client:
            # Use websockets library for the upstream connection
            import websockets

            async with websockets.connect(mlx_server_url) as upstream:
                # Bidirectional proxy
                async def forward_to_client():
                    """Forward messages from MLX Server to frontend."""
                    async for message in upstream:
                        await websocket.send_text(message)

                async def forward_to_upstream():
                    """Forward messages from frontend to MLX Server."""
                    while True:
                        try:
                            data = await websocket.receive_text()
                            await upstream.send(data)
                        except WebSocketDisconnect:
                            break

                # Run both directions concurrently
                await asyncio.gather(
                    forward_to_client(),
                    forward_to_upstream(),
                    return_exceptions=True,
                )
    except Exception as e:
        logger.warning(f"WebSocket proxy error: {e}")
        # Try to inform client before closing
        try:
            await websocket.send_json({
                "type": "error",
                "message": f"Failed to connect to MLX Server: {e}"
            })
        except:
            pass
```

Alternative simpler approach without websockets library (using the existing pattern):

```python
@router.websocket("/ws/audit-logs")
async def proxy_audit_log_stream(websocket: WebSocket) -> None:
    """Proxy WebSocket for audit log streaming.

    Since the MLX Server may run on a different port, this endpoint
    proxies the WebSocket connection. If MLX Server is not running,
    returns an error message.
    """
    await websocket.accept()

    # Try to connect to MLX Server
    mlx_server_ws_url = "ws://localhost:10242/admin/ws/audit-logs"

    try:
        import websockets

        async with websockets.connect(mlx_server_ws_url) as mlx_ws:
            async def receive_from_mlx():
                async for message in mlx_ws:
                    await websocket.send_text(message)

            async def receive_from_client():
                while True:
                    try:
                        data = await websocket.receive_text()
                        await mlx_ws.send(data)
                    except WebSocketDisconnect:
                        return

            done, pending = await asyncio.wait(
                [
                    asyncio.create_task(receive_from_mlx()),
                    asyncio.create_task(receive_from_client()),
                ],
                return_when=asyncio.FIRST_COMPLETED,
            )
            for task in pending:
                task.cancel()

    except Exception as e:
        logger.warning(f"Audit log WebSocket proxy failed: {e}")
        await websocket.send_json({
            "type": "error",
            "message": "MLX Server not available for audit logs"
        })
        await websocket.close()
```

Note: Add `websockets` to dependencies in pyproject.toml if not already present.
  </action>
  <verify>
    - `grep "ws/audit-logs" backend/mlx_manager/routers/system.py`
    - `grep "websocket" backend/mlx_manager/routers/system.py`
  </verify>
  <done>WebSocket proxy endpoint exists in manager API</done>
</task>

<task type="auto">
  <name>Task 3: Add API types for audit logs</name>
  <files>
    frontend/src/lib/api/types.ts
  </files>
  <action>
Update `frontend/src/lib/api/types.ts` to add audit log types:

```typescript
// Add to existing types file

export interface AuditLog {
  id: number;
  request_id: string;
  timestamp: string;
  model: string;
  backend_type: 'local' | 'openai' | 'anthropic';
  endpoint: string;
  duration_ms: number;
  status: 'success' | 'error' | 'timeout';
  prompt_tokens: number | null;
  completion_tokens: number | null;
  total_tokens: number | null;
  error_type: string | null;
  error_message: string | null;
}

export interface AuditLogFilter {
  model?: string;
  backend_type?: string;
  status?: string;
  start_time?: string;
  end_time?: string;
  limit?: number;
  offset?: number;
}

export interface AuditStats {
  total_requests: number;
  by_status: Record<string, number>;
  by_backend: Record<string, number>;
  unique_models: number;
}
```
  </action>
  <verify>
    - `grep "AuditLog" frontend/src/lib/api/types.ts`
  </verify>
  <done>API types for audit logs exist</done>
</task>

<task type="auto">
  <name>Task 4: Add API client functions for audit logs</name>
  <files>
    frontend/src/lib/api/client.ts
  </files>
  <action>
Update `frontend/src/lib/api/client.ts` to add audit log API functions:

```typescript
// Add to existing client file
import type { AuditLog, AuditLogFilter, AuditStats } from './types';

// Use manager API (proxies to MLX Server)
// This allows frontend to connect through the manager on port 5173 (dev) or 10242 (prod)

export async function getAuditLogs(filter: AuditLogFilter = {}): Promise<AuditLog[]> {
  const params = new URLSearchParams();
  if (filter.model) params.set('model', filter.model);
  if (filter.backend_type) params.set('backend_type', filter.backend_type);
  if (filter.status) params.set('status', filter.status);
  if (filter.start_time) params.set('start_time', filter.start_time);
  if (filter.end_time) params.set('end_time', filter.end_time);
  if (filter.limit) params.set('limit', filter.limit.toString());
  if (filter.offset) params.set('offset', filter.offset.toString());

  const response = await fetch(`/api/system/audit-logs?${params}`);
  if (!response.ok) throw new Error('Failed to fetch audit logs');
  return response.json();
}

export async function getAuditStats(): Promise<AuditStats> {
  const response = await fetch('/api/system/audit-logs/stats');
  if (!response.ok) throw new Error('Failed to fetch audit stats');
  return response.json();
}

export function exportAuditLogsUrl(filter: AuditLogFilter = {}, format: 'jsonl' | 'csv' = 'jsonl'): string {
  const params = new URLSearchParams();
  if (filter.model) params.set('model', filter.model);
  if (filter.backend_type) params.set('backend_type', filter.backend_type);
  if (filter.status) params.set('status', filter.status);
  if (filter.start_time) params.set('start_time', filter.start_time);
  if (filter.end_time) params.set('end_time', filter.end_time);
  params.set('format', format);

  return `/api/system/audit-logs/export?${params}`;
}

export function createAuditLogWebSocket(): WebSocket {
  // Connect through manager API proxy (works in dev and prod)
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const host = window.location.host;
  return new WebSocket(`${protocol}//${host}/api/system/ws/audit-logs`);
}
```
  </action>
  <verify>
    - `grep "getAuditLogs" frontend/src/lib/api/client.ts`
    - `grep "createAuditLogWebSocket" frontend/src/lib/api/client.ts`
  </verify>
  <done>API client functions for audit logs exist</done>
</task>

<task type="auto">
  <name>Task 5: Create AuditLogPanel component</name>
  <files>
    frontend/src/lib/components/settings/AuditLogPanel.svelte
    frontend/src/lib/components/settings/index.ts
  </files>
  <action>
1. Create `frontend/src/lib/components/settings/AuditLogPanel.svelte`:
   ```svelte
   <script lang="ts">
     import { onMount, onDestroy } from 'svelte';
     import { Download, RefreshCw, Filter, Wifi, WifiOff } from 'lucide-svelte';
     import { Button } from '$lib/components/ui/button';
     import {
       getAuditLogs,
       getAuditStats,
       exportAuditLogsUrl,
       createAuditLogWebSocket,
     } from '$lib/api/client';
     import type { AuditLog, AuditLogFilter, AuditStats } from '$lib/api/types';

     // State
     let logs = $state<AuditLog[]>([]);
     let stats = $state<AuditStats | null>(null);
     let loading = $state(false);
     let wsConnected = $state(false);
     let ws: WebSocket | null = null;

     // Filters
     let filterModel = $state('');
     let filterBackend = $state('');
     let filterStatus = $state('');
     let offset = $state(0);
     const limit = 50;

     // Load logs with current filters
     async function loadLogs(append = false) {
       loading = true;
       try {
         const filter: AuditLogFilter = {
           limit,
           offset: append ? offset : 0,
         };
         if (filterModel) filter.model = filterModel;
         if (filterBackend) filter.backend_type = filterBackend;
         if (filterStatus) filter.status = filterStatus;

         const newLogs = await getAuditLogs(filter);

         if (append) {
           logs = [...logs, ...newLogs];
         } else {
           logs = newLogs;
           offset = 0;
         }
       } catch (e) {
         console.error('Failed to load logs:', e);
       } finally {
         loading = false;
       }
     }

     // Load stats
     async function loadStats() {
       try {
         stats = await getAuditStats();
       } catch (e) {
         console.error('Failed to load stats:', e);
       }
     }

     // Connect WebSocket for live updates
     function connectWebSocket() {
       try {
         ws = createAuditLogWebSocket();

         ws.onopen = () => {
           wsConnected = true;
         };

         ws.onmessage = (event) => {
           const msg = JSON.parse(event.data);
           if (msg.type === 'log') {
             // Prepend new log to list
             logs = [msg.data, ...logs.slice(0, 99)];
           }
         };

         ws.onclose = () => {
           wsConnected = false;
           // Reconnect after delay
           setTimeout(connectWebSocket, 5000);
         };

         ws.onerror = () => {
           wsConnected = false;
         };
       } catch (e) {
         console.error('WebSocket error:', e);
       }
     }

     // Load more (infinite scroll)
     function loadMore() {
       offset += limit;
       loadLogs(true);
     }

     // Export logs
     function handleExport(format: 'jsonl' | 'csv') {
       const filter: AuditLogFilter = {};
       if (filterModel) filter.model = filterModel;
       if (filterBackend) filter.backend_type = filterBackend;
       if (filterStatus) filter.status = filterStatus;

       const url = exportAuditLogsUrl(filter, format);
       window.open(url, '_blank');
     }

     // Format duration
     function formatDuration(ms: number): string {
       if (ms < 1000) return `${ms}ms`;
       if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
       return `${(ms / 60000).toFixed(1)}m`;
     }

     // Format timestamp
     function formatTime(ts: string): string {
       return new Date(ts).toLocaleString();
     }

     // Status badge color
     function statusColor(status: string): string {
       switch (status) {
         case 'success': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200';
         case 'error': return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200';
         case 'timeout': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200';
         default: return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200';
       }
     }

     onMount(() => {
       loadLogs();
       loadStats();
       connectWebSocket();
     });

     onDestroy(() => {
       if (ws) {
         ws.close();
       }
     });
   </script>

   <div class="space-y-4">
     <!-- Stats row -->
     {#if stats}
       <div class="grid grid-cols-4 gap-4">
         <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-3">
           <div class="text-2xl font-bold">{stats.total_requests}</div>
           <div class="text-sm text-muted-foreground">Total Requests</div>
         </div>
         <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-3">
           <div class="text-2xl font-bold text-green-600">{stats.by_status.success || 0}</div>
           <div class="text-sm text-muted-foreground">Successful</div>
         </div>
         <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-3">
           <div class="text-2xl font-bold text-red-600">{stats.by_status.error || 0}</div>
           <div class="text-sm text-muted-foreground">Errors</div>
         </div>
         <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-3">
           <div class="text-2xl font-bold">{stats.unique_models}</div>
           <div class="text-sm text-muted-foreground">Models Used</div>
         </div>
       </div>
     {/if}

     <!-- Filters and controls -->
     <div class="flex items-center gap-4 flex-wrap">
       <div class="flex items-center gap-2">
         <Filter class="h-4 w-4 text-muted-foreground" />
         <input
           type="text"
           placeholder="Model"
           class="px-2 py-1 border rounded text-sm w-40"
           bind:value={filterModel}
           onchange={() => loadLogs()}
         />
         <select
           class="px-2 py-1 border rounded text-sm"
           bind:value={filterBackend}
           onchange={() => loadLogs()}
         >
           <option value="">All Backends</option>
           <option value="local">Local</option>
           <option value="openai">OpenAI</option>
           <option value="anthropic">Anthropic</option>
         </select>
         <select
           class="px-2 py-1 border rounded text-sm"
           bind:value={filterStatus}
           onchange={() => loadLogs()}
         >
           <option value="">All Status</option>
           <option value="success">Success</option>
           <option value="error">Error</option>
           <option value="timeout">Timeout</option>
         </select>
       </div>

       <div class="flex items-center gap-2 ml-auto">
         <!-- WebSocket status -->
         <span class="flex items-center gap-1 text-sm text-muted-foreground">
           {#if wsConnected}
             <Wifi class="h-4 w-4 text-green-500" />
             <span>Live</span>
           {:else}
             <WifiOff class="h-4 w-4 text-gray-400" />
             <span>Offline</span>
           {/if}
         </span>

         <Button variant="outline" size="sm" onclick={() => loadLogs()}>
           <RefreshCw class="h-4 w-4 mr-1" />
           Refresh
         </Button>
         <Button variant="outline" size="sm" onclick={() => handleExport('jsonl')}>
           <Download class="h-4 w-4 mr-1" />
           JSONL
         </Button>
         <Button variant="outline" size="sm" onclick={() => handleExport('csv')}>
           <Download class="h-4 w-4 mr-1" />
           CSV
         </Button>
       </div>
     </div>

     <!-- Log table -->
     <div class="border rounded-lg overflow-hidden">
       <table class="w-full text-sm">
         <thead class="bg-gray-50 dark:bg-gray-800">
           <tr>
             <th class="px-4 py-2 text-left">Time</th>
             <th class="px-4 py-2 text-left">Model</th>
             <th class="px-4 py-2 text-left">Backend</th>
             <th class="px-4 py-2 text-left">Duration</th>
             <th class="px-4 py-2 text-left">Status</th>
             <th class="px-4 py-2 text-left">Tokens</th>
           </tr>
         </thead>
         <tbody class="divide-y">
           {#each logs as log (log.id)}
             <tr class="hover:bg-gray-50 dark:hover:bg-gray-800">
               <td class="px-4 py-2 text-muted-foreground whitespace-nowrap">
                 {formatTime(log.timestamp)}
               </td>
               <td class="px-4 py-2 font-mono text-xs truncate max-w-[200px]" title={log.model}>
                 {log.model}
               </td>
               <td class="px-4 py-2 capitalize">{log.backend_type}</td>
               <td class="px-4 py-2">{formatDuration(log.duration_ms)}</td>
               <td class="px-4 py-2">
                 <span class={`px-2 py-0.5 rounded text-xs ${statusColor(log.status)}`}>
                   {log.status}
                 </span>
               </td>
               <td class="px-4 py-2">
                 {#if log.total_tokens}
                   {log.total_tokens}
                 {:else}
                   <span class="text-muted-foreground">-</span>
                 {/if}
               </td>
             </tr>
           {:else}
             <tr>
               <td colspan="6" class="px-4 py-8 text-center text-muted-foreground">
                 {#if loading}
                   Loading...
                 {:else}
                   No audit logs found
                 {/if}
               </td>
             </tr>
           {/each}
         </tbody>
       </table>
     </div>

     <!-- Load more -->
     {#if logs.length >= limit}
       <div class="text-center">
         <Button variant="ghost" size="sm" onclick={loadMore} disabled={loading}>
           {#if loading}
             Loading...
           {:else}
             Load More
           {/if}
         </Button>
       </div>
     {/if}
   </div>
   ```

2. Update `frontend/src/lib/components/settings/index.ts`:
   ```typescript
   export { default as ProviderSection } from './ProviderSection.svelte';
   export { default as ModelPoolSettings } from './ModelPoolSettings.svelte';
   export { default as RoutingRulesSection } from './RoutingRulesSection.svelte';
   export { default as AuditLogPanel } from './AuditLogPanel.svelte';
   ```
  </action>
  <verify>
    - `ls frontend/src/lib/components/settings/AuditLogPanel.svelte`
    - `grep "AuditLogPanel" frontend/src/lib/components/settings/index.ts`
  </verify>
  <done>AuditLogPanel component exists and is exported</done>
</task>

<task type="auto">
  <name>Task 6: Integrate AuditLogPanel into settings page</name>
  <files>
    frontend/src/routes/(protected)/settings/+page.svelte
  </files>
  <action>
Update `frontend/src/routes/(protected)/settings/+page.svelte` to add an Audit Logs section at the bottom:

```svelte
<script lang="ts">
  import { ProviderSection, ModelPoolSettings, RoutingRulesSection, AuditLogPanel } from '$lib/components/settings';
</script>

<!-- ... existing sections ... -->

<hr class="border-gray-200 dark:border-gray-700" />

<!-- Audit Logs -->
<section>
  <h2 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">Request Logs</h2>
  <p class="text-sm text-muted-foreground mb-4">
    View and export inference request logs. Live updates when connected.
  </p>
  <AuditLogPanel />
</section>
```
  </action>
  <verify>
    - `grep "AuditLogPanel" frontend/src/routes/(protected)/settings/+page.svelte`
    - `cd frontend && npm run check`
  </verify>
  <done>AuditLogPanel integrated into settings page</done>
</task>

</tasks>

<verification>
Backend verification:
```bash
cd backend && source .venv/bin/activate
pytest tests/mlx_server/ -v
```

Frontend verification:
```bash
cd frontend && npm run check
npm run lint
npm test
```

Manual testing:
1. Start MLX Server: `cd backend && uvicorn mlx_manager.mlx_server.main:app --port 10242`
2. Start manager: `cd backend && uvicorn mlx_manager.main:app --port 10242`
3. Start frontend: `cd frontend && npm run dev`
4. Navigate to Settings page
5. Verify Audit Logs section appears with stats, filters, and table
6. Verify WebSocket connection indicator (connects through manager proxy)
7. Make an inference request and verify it appears in real-time
8. Test filters (model, backend, status)
9. Test export (JSONL and CSV)
</verification>

<success_criteria>
- GET /admin/audit-logs returns paginated logs with filters (on MLX Server)
- GET /admin/audit-logs/stats returns aggregate statistics (on MLX Server)
- GET /admin/audit-logs/export returns JSONL or CSV (on MLX Server)
- WebSocket /api/system/ws/audit-logs proxies to MLX Server through manager
- AuditLogPanel shows stats grid, filters, and log table
- Infinite scroll works (Load More button)
- Export buttons download files
- WebSocket indicator shows connection status
- Filters work correctly
- Settings page includes Audit Logs section
</success_criteria>

<output>
After completion, create `.planning/phases/12-production-hardening/12-05-SUMMARY.md`
</output>
