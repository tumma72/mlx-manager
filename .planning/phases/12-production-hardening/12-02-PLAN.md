---
phase: 12-production-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/mlx_manager/mlx_server/errors/__init__.py
  - backend/mlx_manager/mlx_server/errors/problem_details.py
  - backend/mlx_manager/mlx_server/errors/handlers.py
  - backend/mlx_manager/mlx_server/main.py
  - backend/tests/mlx_server/test_error_handlers.py
autonomous: true

must_haves:
  truths:
    - "All API errors return RFC 7807 Problem Details format"
    - "Every error response includes request_id for log correlation"
    - "HTTP status codes are correct (4xx for client errors, 5xx for server errors)"
    - "Internal error details (stack traces) are never exposed"
    - "SSE streaming errors send error event before connection close"
  artifacts:
    - path: "backend/mlx_manager/mlx_server/errors/problem_details.py"
      provides: "RFC 7807 ProblemDetail Pydantic model"
      exports: ["ProblemDetail", "TimeoutProblem"]
    - path: "backend/mlx_manager/mlx_server/errors/handlers.py"
      provides: "FastAPI exception handlers"
      exports: ["register_error_handlers"]
  key_links:
    - from: "mlx_server/main.py"
      to: "errors/handlers.py"
      via: "register_error_handlers(app) call"
      pattern: "register_error_handlers\\(app\\)"
    - from: "errors/handlers.py"
      to: "errors/problem_details.py"
      via: "ProblemDetail import and instantiation"
      pattern: "ProblemDetail\\("
---

<objective>
Implement RFC 7807 Problem Details error responses with request_id

Purpose: PROD-02 requires unified error responses with consistent format and proper HTTP status codes. Every error must include request_id for log correlation. The format should be RFC 7807 (Problem Details) as decided in CONTEXT.md.

Output: All API errors return structured Problem Details responses with request_id
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-production-hardening/12-CONTEXT.md
@.planning/phases/12-production-hardening/12-RESEARCH.md
@backend/mlx_manager/mlx_server/main.py
@backend/mlx_manager/mlx_server/api/v1/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RFC 7807 Problem Details models and exception classes</name>
  <files>
    backend/mlx_manager/mlx_server/errors/__init__.py
    backend/mlx_manager/mlx_server/errors/problem_details.py
  </files>
  <action>
1. Create `backend/mlx_manager/mlx_server/errors/__init__.py`:
   ```python
   """Error handling for MLX Server."""

   from mlx_manager.mlx_server.errors.handlers import register_error_handlers
   from mlx_manager.mlx_server.errors.problem_details import (
       ProblemDetail,
       TimeoutHTTPException,
       TimeoutProblem,
   )

   __all__ = [
       "ProblemDetail",
       "TimeoutProblem",
       "TimeoutHTTPException",
       "register_error_handlers",
   ]
   ```

2. Create `backend/mlx_manager/mlx_server/errors/problem_details.py`:
   ```python
   """RFC 7807/9457 Problem Details models.

   Provides structured error responses per RFC 7807:
   https://datatracker.ietf.org/doc/html/rfc7807
   """

   from typing import Any

   from fastapi import HTTPException
   from pydantic import BaseModel, Field


   class ProblemDetail(BaseModel):
       """RFC 7807 Problem Details response.

       All API errors are returned in this format for consistency.
       Always includes request_id for log correlation.
       """

       type: str = Field(
           default="about:blank",
           description="URI reference identifying the problem type",
       )
       title: str = Field(
           description="Human-readable summary (not occurrence-specific)",
       )
       status: int = Field(
           description="HTTP status code",
       )
       detail: str | None = Field(
           default=None,
           description="Human-readable explanation specific to this occurrence",
       )
       instance: str | None = Field(
           default=None,
           description="URI reference for this specific occurrence",
       )
       request_id: str = Field(
           description="Request ID for log correlation",
       )

       # Extension fields (RFC 7807 allows additional members)
       errors: list[dict[str, Any]] | None = Field(
           default=None,
           description="Validation errors (for 422 responses)",
       )


   class TimeoutProblem(ProblemDetail):
       """Problem Details for timeout errors."""

       type: str = "https://mlx-manager.dev/errors/timeout"
       title: str = "Request Timeout"
       status: int = 408
       timeout_seconds: float = Field(
           description="Configured timeout that was exceeded",
       )


   class TimeoutHTTPException(HTTPException):
       """Custom exception for endpoint timeouts.

       Carries timeout information for proper Problem Details response.
       """

       def __init__(
           self,
           timeout_seconds: float,
           detail: str | None = None,
       ) -> None:
           super().__init__(
               status_code=408,
               detail=detail or f"Request timed out after {timeout_seconds} seconds",
           )
           self.timeout_seconds = timeout_seconds
   ```
  </action>
  <verify>
    - `python -c "from mlx_manager.mlx_server.errors.problem_details import ProblemDetail, TimeoutHTTPException; print('OK')"`
    - `ls backend/mlx_manager/mlx_server/errors/problem_details.py`
  </verify>
  <done>RFC 7807 ProblemDetail model and TimeoutHTTPException class exist</done>
</task>

<task type="auto">
  <name>Task 2: Create exception handlers with request_id generation</name>
  <files>
    backend/mlx_manager/mlx_server/errors/handlers.py
  </files>
  <action>
Create `backend/mlx_manager/mlx_server/errors/handlers.py`:

```python
"""FastAPI exception handlers for RFC 7807 responses.

Registers handlers that convert all exceptions to Problem Details format.
Generates request_id for every error for log correlation.
"""

import logging
import uuid
from typing import Any

from fastapi import FastAPI, HTTPException, Request
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from pydantic import ValidationError

from mlx_manager.mlx_server.errors.problem_details import (
    ProblemDetail,
    TimeoutHTTPException,
    TimeoutProblem,
)

logger = logging.getLogger(__name__)


def generate_request_id() -> str:
    """Generate unique request ID for log correlation."""
    return f"req_{uuid.uuid4().hex[:12]}"


async def http_exception_handler(
    request: Request,
    exc: HTTPException,
) -> JSONResponse:
    """Handle HTTPException with Problem Details response."""
    request_id = generate_request_id()

    # Log the error with request_id for correlation
    logger.warning(
        f"HTTP {exc.status_code} error: {exc.detail}",
        extra={"request_id": request_id, "path": request.url.path},
    )

    # Map common status codes to problem types
    problem_types = {
        400: "https://mlx-manager.dev/errors/bad-request",
        401: "https://mlx-manager.dev/errors/unauthorized",
        403: "https://mlx-manager.dev/errors/forbidden",
        404: "https://mlx-manager.dev/errors/not-found",
        422: "https://mlx-manager.dev/errors/validation-error",
        429: "https://mlx-manager.dev/errors/rate-limited",
        500: "https://mlx-manager.dev/errors/internal-error",
        503: "https://mlx-manager.dev/errors/service-unavailable",
    }

    problem_titles = {
        400: "Bad Request",
        401: "Unauthorized",
        403: "Forbidden",
        404: "Not Found",
        422: "Validation Error",
        429: "Too Many Requests",
        500: "Internal Server Error",
        503: "Service Unavailable",
    }

    problem = ProblemDetail(
        type=problem_types.get(exc.status_code, "about:blank"),
        title=problem_titles.get(exc.status_code, "Error"),
        status=exc.status_code,
        detail=str(exc.detail) if exc.detail else None,
        instance=str(request.url.path),
        request_id=request_id,
    )

    return JSONResponse(
        status_code=exc.status_code,
        content=problem.model_dump(exclude_none=True),
        headers={"X-Request-ID": request_id},
    )


async def timeout_exception_handler(
    request: Request,
    exc: TimeoutHTTPException,
) -> JSONResponse:
    """Handle TimeoutHTTPException with specialized Problem Details."""
    request_id = generate_request_id()

    logger.warning(
        f"Request timeout after {exc.timeout_seconds}s: {request.url.path}",
        extra={"request_id": request_id},
    )

    problem = TimeoutProblem(
        detail=exc.detail,
        instance=str(request.url.path),
        request_id=request_id,
        timeout_seconds=exc.timeout_seconds,
    )

    return JSONResponse(
        status_code=408,
        content=problem.model_dump(exclude_none=True),
        headers={"X-Request-ID": request_id},
    )


async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError,
) -> JSONResponse:
    """Handle Pydantic validation errors with Problem Details."""
    request_id = generate_request_id()

    # Extract validation errors
    errors: list[dict[str, Any]] = []
    for error in exc.errors():
        errors.append({
            "field": ".".join(str(loc) for loc in error.get("loc", [])),
            "message": error.get("msg", "Validation error"),
            "type": error.get("type", "unknown"),
        })

    logger.warning(
        f"Validation error: {len(errors)} errors",
        extra={"request_id": request_id, "path": request.url.path},
    )

    problem = ProblemDetail(
        type="https://mlx-manager.dev/errors/validation-error",
        title="Validation Error",
        status=422,
        detail=f"Request validation failed with {len(errors)} error(s)",
        instance=str(request.url.path),
        request_id=request_id,
        errors=errors,
    )

    return JSONResponse(
        status_code=422,
        content=problem.model_dump(exclude_none=True),
        headers={"X-Request-ID": request_id},
    )


async def generic_exception_handler(
    request: Request,
    exc: Exception,
) -> JSONResponse:
    """Handle unexpected exceptions without exposing internals."""
    request_id = generate_request_id()

    # Log full exception for debugging, but don't expose to client
    logger.exception(
        f"Unhandled exception: {type(exc).__name__}",
        extra={"request_id": request_id, "path": request.url.path},
    )

    problem = ProblemDetail(
        type="https://mlx-manager.dev/errors/internal-error",
        title="Internal Server Error",
        status=500,
        detail="An unexpected error occurred. Please try again later.",
        instance=str(request.url.path),
        request_id=request_id,
    )

    return JSONResponse(
        status_code=500,
        content=problem.model_dump(exclude_none=True),
        headers={"X-Request-ID": request_id},
    )


def register_error_handlers(app: FastAPI) -> None:
    """Register all exception handlers on the FastAPI app.

    Call this after creating the FastAPI app but before adding routes.
    """
    app.add_exception_handler(TimeoutHTTPException, timeout_exception_handler)
    app.add_exception_handler(HTTPException, http_exception_handler)
    app.add_exception_handler(RequestValidationError, validation_exception_handler)
    app.add_exception_handler(Exception, generic_exception_handler)
    logger.info("RFC 7807 error handlers registered")
```
  </action>
  <verify>
    - `python -c "from mlx_manager.mlx_server.errors.handlers import register_error_handlers; print('OK')"`
    - File exists: `ls backend/mlx_manager/mlx_server/errors/handlers.py`
  </verify>
  <done>Exception handlers convert all errors to RFC 7807 format with request_id</done>
</task>

<task type="auto">
  <name>Task 3: Integrate error handlers into MLX Server and add tests</name>
  <files>
    backend/mlx_manager/mlx_server/main.py
    backend/tests/mlx_server/test_error_handlers.py
  </files>
  <action>
1. Update `mlx_server/main.py` to register error handlers:
   - Import `register_error_handlers` from errors module
   - Call `register_error_handlers(app)` AFTER app creation but BEFORE including routers

   Add after app creation:
   ```python
   from mlx_manager.mlx_server.errors import register_error_handlers

   app = FastAPI(...)
   register_error_handlers(app)

   # Include API routers
   app.include_router(v1_router)
   ```

2. Create `backend/tests/mlx_server/test_error_handlers.py`:
   ```python
   """Tests for RFC 7807 error handlers."""

   import pytest
   from fastapi import FastAPI, HTTPException
   from fastapi.testclient import TestClient

   from mlx_manager.mlx_server.errors import (
       ProblemDetail,
       TimeoutHTTPException,
       register_error_handlers,
   )


   @pytest.fixture
   def app() -> FastAPI:
       """Create test app with error handlers."""
       app = FastAPI()
       register_error_handlers(app)

       @app.get("/ok")
       async def ok():
           return {"status": "ok"}

       @app.get("/not-found")
       async def not_found():
           raise HTTPException(status_code=404, detail="Model not found")

       @app.get("/timeout")
       async def timeout():
           raise TimeoutHTTPException(timeout_seconds=60.0)

       @app.get("/server-error")
       async def server_error():
           raise RuntimeError("Unexpected failure")

       @app.post("/validation")
       async def validation(data: dict):
           if "required_field" not in data:
               raise HTTPException(status_code=422, detail="Missing required_field")
           return data

       return app


   @pytest.fixture
   def client(app: FastAPI) -> TestClient:
       return TestClient(app)


   def test_successful_request(client: TestClient) -> None:
       """Successful requests return normal JSON."""
       response = client.get("/ok")
       assert response.status_code == 200
       assert response.json() == {"status": "ok"}


   def test_http_exception_returns_problem_details(client: TestClient) -> None:
       """HTTPException returns RFC 7807 Problem Details."""
       response = client.get("/not-found")
       assert response.status_code == 404
       data = response.json()

       # Verify Problem Details structure
       assert data["type"] == "https://mlx-manager.dev/errors/not-found"
       assert data["title"] == "Not Found"
       assert data["status"] == 404
       assert data["detail"] == "Model not found"
       assert "request_id" in data
       assert data["request_id"].startswith("req_")

       # Verify X-Request-ID header
       assert "X-Request-ID" in response.headers
       assert response.headers["X-Request-ID"] == data["request_id"]


   def test_timeout_exception_returns_timeout_problem(client: TestClient) -> None:
       """TimeoutHTTPException returns specialized timeout Problem Details."""
       response = client.get("/timeout")
       assert response.status_code == 408
       data = response.json()

       assert data["type"] == "https://mlx-manager.dev/errors/timeout"
       assert data["title"] == "Request Timeout"
       assert data["status"] == 408
       assert data["timeout_seconds"] == 60.0
       assert "request_id" in data


   def test_generic_exception_returns_500_without_internals(client: TestClient) -> None:
       """Unhandled exceptions return 500 without exposing internals."""
       response = client.get("/server-error")
       assert response.status_code == 500
       data = response.json()

       assert data["type"] == "https://mlx-manager.dev/errors/internal-error"
       assert data["title"] == "Internal Server Error"
       assert data["status"] == 500
       # Must NOT contain stack trace or internal error message
       assert "RuntimeError" not in str(data)
       assert "Unexpected failure" not in str(data)
       assert "request_id" in data


   def test_request_id_unique_per_request(client: TestClient) -> None:
       """Each error request gets unique request_id."""
       response1 = client.get("/not-found")
       response2 = client.get("/not-found")

       id1 = response1.json()["request_id"]
       id2 = response2.json()["request_id"]

       assert id1 != id2
   ```
  </action>
  <verify>
    - `cd backend && python -c "from mlx_manager.mlx_server.main import app; print('OK')"`
    - `cd backend && pytest tests/mlx_server/test_error_handlers.py -v`
  </verify>
  <done>Error handlers integrated and tested</done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
cd backend && source .venv/bin/activate
pytest tests/mlx_server/test_error_handlers.py -v
pytest tests/mlx_server/ -v
```

Manual verification:
```bash
# Start server and test error response
cd backend && uvicorn mlx_manager.mlx_server.main:app --port 10242 &
sleep 2
curl -s http://localhost:10242/v1/models/nonexistent | jq .
# Should return Problem Details with request_id
kill %1
```
</verification>

<success_criteria>
- All HTTPExceptions return RFC 7807 Problem Details format
- Every error response has request_id field
- X-Request-ID header matches response body request_id
- Internal errors (500) don't expose stack traces or internal messages
- TimeoutHTTPException returns specialized timeout problem
- All error handler tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-production-hardening/12-02-SUMMARY.md`
</output>
